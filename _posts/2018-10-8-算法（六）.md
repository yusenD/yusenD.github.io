---
layout: post
title: 算法————栈
feature-img: "assets/img/background/pexels-photo10.jpeg"
thumbnail: "assets/img/background/pexels-photo10.jpeg"
tags: [面试,算法]
---

> Perhaps one did not want to be loved so much as to be understood.                       
> <p align="right">——乔治·奥威尔</p>


* TOC
{: toc}

### 简介
----

栈是一种**先进后出**的数据结构，从操作特性上看，栈只允许在一端插入和删除数据。

相对于数组和链表，栈的“操作受限”更大。事实上，很多情况下，数组链表完全可以代替栈，但是，特定的数据数据结构是对特定场景的抽象。数组和链表暴露了太多的操作接口，尽管操作灵活，不过使用时候也就更容易出错了。

### 实现
----

那么如何实现一个栈呢？

栈的操作主要有两个，即入栈（push）和出栈（pop）。所以我们可以用数组和链表来实现。用数组实现的栈结构，称为顺序栈；用链表实现的栈，称为链式栈。

下面分别实现一下：

数组实现
{% highlight java%}
//等我补上
{% endhighlight %}

链表实现
{% highlight java%}
//等我补上！
{% endhighlight %}

### 复杂度分析
----

看一下出栈入栈两种操作的时间空间复杂度吧。

时间复杂度：很明显，都是$$O(1)$$

空间复杂度：emmmm 也是很明显，都是$$O(1)$$

### 动态扩容的顺序栈
----

刚才用数组实现的是固定大小的一个栈，当栈满的时候，就无法再往栈里面添加数据了。实现思路和在数组那里的类似，满了的时候，申请一个更大的数组，然后把原来的数组复制进去。

实时上，这种顺序栈在开发中是不常用到的，所以着重分析一下这种顺序栈操作的时间复杂度。

**出栈**：这个还是$$O(1)$$

**入栈**：在没满的时候，还是$$O(1)$$无疑，但是当栈满需要扩容的时候，要进行复制操作，时间复杂度变成了$$O(n)$$。入栈操作的最好时间复杂度为$$O(1)$$，最差为$$O(n)$$。

平均时间复杂度：
均摊时间复杂度:


### 应用
----

#### 函数调用栈
我们知道，操作系统会给每个线程分配一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每次进入一个函数，就会将临时变量作为一个栈帧入栈，调用执行完成，返回之后，再将这个函数对应的栈帧出栈。下面看一下这段代码的执行过程。

{% highlight c%}
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}

{% endhighlight %}

 ![](https://i.loli.net/2018/10/10/5bbdc38016be0.jpg)


#### 表达式求值

以一个四则运算算式为例：`2+3*4-6/3`

人脑可以比较容易的就算出来了，不过对于计算机来说，理解就挺麻烦的了。实际上，我们的编译器就是通过两个栈来实现的，一个用于保存操作数的栈，另一个是用于保存运算符的栈。

从左到右遍历表达式，遇到数字进操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，如果优先级要高就要放进运算符栈，如果低就进行运算，取栈顶两个操作数，取栈顶一个操作数进行运算，并且将结果压进操作数栈。

对于这个运算式子的话：

![](https://i.loli.net/2018/10/10/5bbdc39222dc4.jpg)


代码实现：

{% highlight java%}



{% endhighlight %}




#### 括号匹配

这个很好理解，在检索括号是否匹配的时候，`[] {} ()`，利用栈，读到左括号压栈，读到右括号看栈顶是否匹配，如果不匹配说明是非法的，如果匹配继续读。读完之后，栈为空的话，那么说明括号匹配，否则非法。

代码实现：

{% highlight java%}



{% endhighlight %}


### 思考

1.函数调用用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？

> 函数嵌套调用的时候，符合先进后出的原则，即代码顺序执行，当遇到子函数，要等子函数执行完成之后，主函数才能继续执行。

2.JVM内存管理中有个“堆栈的概念”，栈内存用来存储局部变量和方法调用，堆内存用来存储Java中的对象。那么JVM里面的“栈”和这里说的“栈”是不是一回事呢？

> 显然不是一个概念。
> 
> 内存中的堆栈是真是存在的物理区，而数据结构的“栈”，是一种抽象的数据存储结构。
> 
> **数据结构的堆栈：**
>   
>   * 栈：是一种连续存储的数据结构，特点是存储的数据先进后出。
> 
>   * 堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大顶堆和小顶堆）。它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。
>       
> **内存的堆栈：**
> 
> 内存在空间上分为三部分：代码区、静态数据区和动态数据区。其中动态数据又分为堆和栈
> 
>   * 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
> 
>   * 静态数据区：存储全局变量、静态变量、常量。常量包括final修饰的常量和String常量，由系统自动分配和回收。
> 
>   * 动态数据区：
> 
>       * 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。例如 `int method(int a){int b; return temp;}`。栈中存储参数a、局部变量b、返回值temp。
> 
>       * 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java中由JVM虚拟机的垃圾回收机制自动回收）。比如，在C中用malloc函数` p1 = (char*) malloc(10); `；在JAVA中用` new `，都将分配堆区空间。不过要注意p1本身是在栈中。


