---
layout: post
title: 汇编（三）——逻辑运算指令
feature-img: "assets/img/background/pexels-photo9.jpeg"
tags: [汇编]
---

<br>

## 逻辑运算类指令

* 对操作数的要求
    * 大多与MOV指令相同
    * “非”运算指令要求操作数不能是立即数，如果是存储器操作数必须要给出字长（PTR指令）
* 对标志位的影响
    * 除了“非”指令，其余指令会影响AF之外的标志位
    * 无论运算结果如何，都会使得OF=CF=0
    * “非”运算指令的执行不影响标志位

### 1.“与”指令

> AND OPRD1,OPRD2

* 实现两操作数按位相与的运算，如`AND BL, [SL]`

* 还可以使得目标操作数的某些位不变，某些位清零，如`AND AL, 0FH`，前四位清零，第四位不变，就相当于**屏蔽掉了**。

### 2.“或”指令

> OR OPRD1, OPRD2

* 实现两操作数相“或”运算 `OR AX, [DI]`
* 使得CF=OF=0 `OR AX, AX`
* 使得某些为不变，某些位为1，`OR AX, OFH`

### 3.“非”运算

> NOT OPRD

不会对标志位产生影响。`NOT BYTE PTR[BX]`

### 4.“异或”运算

> XOR OPRD1, OPRD2

结果送往目的地址

`XOR AX, AX` 相当于对AX清零（效果最好，比立即数快）

### 5.“测试”指令

> TEST OPRD1, OPRD2

执行与操作，但是运算的结果不送回目标地址，经常用于测试某些位的状态

例子🌰：
从地址为3F8H的端口读入一个字节数，当该数的bit1，bit3，bit5同时为1时，可以从3F8H端口将DATA为首地址的一个字输出，否则就不能进行数据传输。

{% highlight java%}
    
    LEA SI, DATA
    MOV DX, 3F8H
    WATT: IN AL, DX
    
    TEST AL, 02H
    JZ WATT ; ZF=1转移(是否为0标志，如果为0的话，说明不一样)
    TEST AL, 08H
    JZ WATT
    TEST AL, 20H
    JZ WATT
    
    MOV DX, 38FH
    MOV AX, [SI]
    OUT DX, AX
    
    ;上面有一大段重复的代码，可以进行优化
    
    AND AL, 2AH
    XOR AL, 2AH
    JNZ WATT
      
{% endhighlight %}


## 移位操作指令

* 共有两类，分为循环和非循环
* 目标操作数为被移动对象，源操作数为移动次数
    * 当目标操作数为存储器操作数的时候，需要指定字长
    * 不能是立即数
* 移动1位的时候可以直接写出来，如果移动多次只能是用CL

### 1.非循环移位指令——算数左移和逻辑左移/右移

> SAL OPRD, 1 算数————针对有符号数
> SHL OPRD, CL 逻辑————针对无符号数

左移：最高位移动到CF里面，最低位补零

> SHR OPRD, 1
> SHR OPRD, CL

右移：如果是逻辑最高位补零，如果是算数最高位复制最高位；最低位移动到CF

#### 例子🌰：

逻辑右移：
> * MOV AL, 68H
> * MOV CL, 2
> * SHR AL, CLH
> 
> 68H逻辑右移两次，AL变成00011010，CF=0

算数右移：
> AL: 11101000
> * SAR AL, 1
> 
> 符号为复制一下，接着放到最高位，AL为11110100,CF=0

### 2.循环移位指令——带进位位的循环移位/不带

格式和非循环一样的

略，都差不多，就是移动之后，要补的数和CF里面一样




