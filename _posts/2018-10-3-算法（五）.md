---
layout: post
title: 算法————链表
feature-img: "assets/img/background/pexels-photo9.jpeg"
thumbnail: "assets/img/background/pexels-photo9.jpeg"
tags: [面试,算法]
---

> 我用你的双手丈量了世界， <br>
> 我用你的肩头做纯净的天平。                   
> <p align="right">——索菲亚·安德雷森</p>

* TOC
{: toc}

<br>

## 链表介绍

### 链表结构
----

常用常见的主要有三种结构：单链表、循环链表、双向链表、双向循环等，不再赘述。

以删除操作为例，实际开发中，插入数据基本就这两种情况：

* 删除等于这个值的结点
* 删除给定的结点

对于第一种情况，所有链表都要从头开始进行遍历，找到结点之后进行删除操作，删除操作只需要改变指针，时间复杂度为$$O(1)$$，遍历的时间复杂度是$$O(n)$$，所以整体的删除时间复杂度为$$O(n)$$。

对于第二种情况，单链表删除结点并不能获取其前驱结点，所以为了找到前驱结点，还要从头遍历，而双向链表就很方便了，只需要$$O(1)$$的时间复杂度。同样的，对于插入操作，双向链表也比单链表要高效。

其实除了插入和删除操作有优势之外，对于有序链表，双向链表的查询也要更高效，第一次查询记下P值，第二次查询只要和P比较就可以知道应该往后还是往前查找了。

这样来看，双向链表确实是要比单链表更高效，这也是为什么在实际开发的时候，尽管双向链表更费内存，但还是比单链表应用广泛，也就是典型的**空间换时间**。Java中，LinkedHashMap这个容器，实现原理就用到了双向链表这种数据结构。

### 和数组比较一下
----

上一章里面画了个图，比较了两者的删除、插入、随机访问的时间复杂度。但是数组和链表的对比并不能局限于时间复杂度。**在实际开发时，不能仅利用复杂度分析就决定使用哪个数据结构。**

数组很简单，利用的是连续的内存空间，可以借助**CPU的缓存机制**，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储的，对CPU缓存不友好，不能有效预读。

> CPU缓存机制：
> 
> CPU在从内存读取数据的时候，会先把读到的数据加载到CPU的缓存当中，而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是要读取一个数据块，并且保存到CPU的缓存中，然后下次访问内存数据的时候，会先从CPU的缓存查找，如果找到就不需要再从内存中读取。这就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义（联动：程序的时间局限性）：弥补内存访问速度过慢与CPU执行速度快之间的差异。
> 
> 对于数组来说，存储空间是连续的，CPU缓存很大可能会把数组加进去，这样执行速度就会快于存储空间不连续的链表

数组的缺点是大小固定，声明的时候就要占用整块的连续内存。如果数组声明过大，系统很可能没有足够的连续内存空间分配给他，导致OOM；如果声明过小，当数组放不下了，就要再申请一个更大的数组，把原来的数组复制过去，非常的耗时。

比如Java的ArrayList，看一下源码实现：

{% highlight java%}

//默认的构造函数，初始容量为10
public ArrayList() {
    super();
    this.elementData = EMPTY_ELEMENTDATA;
}

// 将此 ArrayList 实例的容量调整为列表的当前大小(实际元素个数)
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = Arrays.copyOf(elementData, size);
    }
}

{% endhighlight %}

如果可用内存少，那还是数组就更适合。因为链表的每个结点都要消耗额外的空间去存储指针，而且频繁的插入删除等操作会导致频繁的内存申请和释放，更容易造成内存碎片。


## 使用注意

### 警惕指针丢失和内存泄漏
----

举个例子🌰：

![](https://i.loli.net/2018/10/09/5bbca53c9e145.jpg)

如上图，我们想要插入结点x,使用代码：

```
p.next = x;
x.next = p.next;
```

初学者很容易犯错，这样使得b及以后的结点无法访问，造成了指针丢失。正确代码：

```
x.next = p.next;
p.next = x;
```

对于有些语言来说，比如C语言，是需要程序员手动释放内存空间的，如果忘了，就产生了内存泄漏。但是对于Java这样的有自动管理内存机制的语言来说，就不需要考虑这么多了。

### 使用头结点简化实现难度
----

链表在链表尾部插入新结点new_node：

```
if(head==null) head = new_node;
else{
    new_node.next = tail.next;
    tail.next = new_node;
}
```

链表删除结点p之后的结点：

```
if(tail==head) head = null;
else{
    if(p.next!=null) p.next = p.next.next;
}
```

可以看到，无论是插入操作还是删除操作，都有一个判空，这时引入一个头结点head，不存数据。这样，插入第一个结点，删除第一个结点，都是head.next，使得操作更加简单了。

这种利用**哨兵**简化代码的技巧有很多地方都用到。

再举个例子🌰：

在一个数组a中查找key值，返回其在数组中的位置：

{% highlight java%}
方法一：
/*
常规操作
*/
int find(char key){
    for(int i=0;i<len;i++){
        if(a[i]==key) return i;
    }
    return -1
}

方法二：利用哨兵减少一次操作
/* 
思路：耗时操作主要是在循环里面，循环每次都会进行i<len的比较，这个利用哨兵是可以去掉的。因为循环的目的是要保证数组被遍历完，那么遍历完和比较key值可以合起来，即把数组最后一个值改成和key值相等，当key值相等就退出循环，然后再判断此时的位置是不是最后一个位置即可。
*/
int find(char key){
    if(a[n-1]==key) return n-1;
    char temp = a[n-1];
    a[n-1] = key;结点
    while(a[i]!=key){
        i++;
    }
    a[n-1] = temp;
    if(i==n-1) return -1
    return i;
}
{% endhighlight %}

### 注意边界条件处理
----

 代码在边界情况最容易产生BUG。对于链表来说，需要特别注意下面的几个边界情况：

* 链表为空
* 链表只有一个结点
* 链表只有两个结点
* 代码在处理头结点和尾结点的时候

## 应用

### 链表常用的几个操作：
----

#### 1.链表反转

思路：用两个辅助指针 pre和next
{% highlight java%}

node reverse(){
    pre = null;
    while(head!=null){
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    return pre;
}

{% endhighlight %}


#### 2.链表中环的检查

#### 3.两个有序链表合并

{% highlight java%}


{% endhighlight %}

#### 4.删除链表倒数第n个节点

{% highlight java%}

// 下意识的想到= = 先反转，然后再删除，当然这个不行
/* 
思路：这个用两个指针来实现，目的是最后一个节点到尾部的时候，前一个指针刚好指在第n个位置，也就是他们之间的位置差了n，所以最开始一个节点先走n，这样距离就有了
*/
node deleteNon(int n){
    node fast = head;
    node slow = head;
    for(int i=0;i<n;i++){
        if(fast!=null) fast = fast.next;
        else return;
    }
    while(fast!=null){
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
 

{% endhighlight %}
 
#### 5.求链表的中间节点

{% highlight java%}

思路：可以设置两个指针，一个快指针，一个慢指针，每次fast前进两个，slow前进一个，这样，当fast到最后的时候，slow指向的就是中间节点。

node findMid(){
    node fast = head;
    node slow = head;
    while(fast.next!=null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}

{% endhighlight %}


### 实现LRU缓存淘汰算法
----

如何用链表实现LRU缓存淘汰策略？

> 缓存是一种提高数据读取性能的技术，应用非常的广泛。缓存的大小是有限的，当内存被占用满时，哪些数据需要保留，哪些需要被清除，这就需要一个缓存的淘汰策略。常见的策略有三种：先进先出FIFO（First in First out）、最少使用LFU（Least Frequently Used）、最少使用策略LRU（Least Recently Used）。

思路：维护一个有序的单链表，越靠近尾部的结点就是越早之前访问的，当有一个新的数据开始访问的时候，我们从链表头开始遍历：

> 1）如果数据已经缓存在链表里了，那么得到这个结点之后，就把该结点从原来的位置删除，并且放在链表头部。
> 2）如果该数据没有缓存在链表里面那么又是两种情况：
>   * 如果此时缓存满了，那么把尾结点删除，插入头部
>   * 如果没满，直接插入头部

伪代码实现：

{% highlight java%}
/*
链表头结点：linked
中间结点：p、temp
当前缓存大小：curMem
最大缓存大小：maxMex
*/
node find(int s){
    for(int i=0;i<curMem;i++){ 
        if(p.next.data == s){ //如果已经存在结点了
            temp = p.next;
            p.next = temp.next;
            linked = temp;
            return linked;
        }
        else{
            p=p.next;
        }
    }
    return null;
}

void insert(node temp){
    if(curMem==maxMem){
        release(tail); //释放尾结点
    }
    temp.next = linked;
}

{% endhighlight %}


### 回文字符串

如果一个字符串是通过单链表存储的，我们该如何判断是一个回文串呢？

[234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description/)

思路：可以设置两个指针，一个快指针fast，一个慢指针slow，fast每次跳两个结点，slow每次跳一个结点，并且改变next指向的位置。当fast访问到最后结点的时候，slow刚好在中间。

伪代码实现：

{% highlight java%}

/*
指针：head,slow,fast
字符串长度：len
*/

boolean isParlindrome(str){
    if(str.length==1) return true;
    else{
        head = str;
        temp1 = slow.next;
        while(fast != null){
            fast = fast.next;
            if(fase != null) fast = fast.next;
            slow = slow.next;
        }   
        slow = reverse(slow);
        while(slow!=null){
            if(head != slow) return false;
            head = head.next;
            slow = slow.next;
        }
        return true;
    }
}

node reverse(node p){
    node prev = null;
    node next = null;
    while(p.next!=null){
        next = p.next;
        p.next = prev;
        prev = p;
        p = next;
    }
    return p;
}


{% endhighlight %}




