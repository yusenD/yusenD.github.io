---
layout: post
title: 算法————链表
feature-img: "assets/img/background/pexels-photo9.jpeg"
thumbnail: "assets/img/background/pexels-photo9.jpeg"
tags: [面试,算法]
---

> 我用你的双手丈量了世界， <br>
> 我用你的肩头做纯净的天平。                   
> <p align="right">——索菲亚·安德雷森</p>

* TOC
{: toc}

<br>

## 链表介绍

### 链表结构
----

常用常见的主要有三种结构：单链表、循环链表、双向链表、双向循环等，不再赘述。

以删除操作为例，实际开发中，插入数据基本就这两种情况：

* 删除等于这个值的节点
* 删除给定的节点

对于第一种情况，所有链表都要从头开始进行遍历，找到节点之后进行删除操作，删除操作只需要改变指针，时间复杂度为$$O(1)$$，遍历的时间复杂度是$$O(n)$$，所以整体的删除时间复杂度为$$O(n)$$。

对于第二种情况，单链表删除节点并不能获取其前驱节点，所以为了找到前驱节点，还要从头遍历，而双向链表就很方便了，只需要$$O(1)$$的时间复杂度。同样的，对于插入操作，双向链表也比单链表要高效。

其实除了插入和删除操作有优势之外，对于有序链表，双向链表的查询也要更高效，第一次查询记下P值，第二次查询只要和P比较就可以知道应该往后还是往前查找了。

这样来看，双向链表确实是要比单链表更高效，这也是为什么在实际开发的时候，尽管双向链表更费内存，但还是比单链表应用广泛，也就是典型的**空间换时间**。Java中，LinkedHashMap这个容器，实现原理就用到了双向链表这种数据结构。

### 和数组比较一下
----

上一章里面画了个图，比较了两者的删除、插入、随机访问的时间复杂度。但是数组和链表的对比并不能局限于时间复杂度。**在实际开发时，不能仅利用复杂度分析就决定使用哪个数据结构。**

数组很简单，利用的是连续的内存空间，可以借助**CPU的缓存机制**，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储的，对CPU缓存不友好，不能有效预读。

> CPU缓存机制：
> 
> CPU在从内存读取数据的时候，会先把读到的数据加载到CPU的缓存当中，而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是要读取一个数据块，并且保存到CPU的缓存中，然后下次访问内存数据的时候，会先从CPU的缓存查找，如果找到就不需要再从内存中读取。这就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义（联动：程序的时间局限性）：弥补内存访问速度过慢与CPU执行速度快之间的差异。
> 
> 对于数组来说，存储空间是连续的，CPU缓存很大可能会把数组加进去，这样执行速度就会快于存储空间不连续的链表

数组的缺点是大小固定，声明的时候就要占用整块的连续内存。如果数组声明过大，系统很可能没有足够的连续内存空间分配给他，导致OOM；如果声明过小，当数组放不下了，就要再申请一个更大的数组，把原来的数组复制过去，非常的耗时。

比如Java的ArrayList，看一下源码实现：

{% highlight java%}

//默认的构造函数，初始容量为10
public ArrayList() {
    super();
    this.elementData = EMPTY_ELEMENTDATA;
}

// 将此 ArrayList 实例的容量调整为列表的当前大小(实际元素个数)
public void trimToSize() {
    modCount++;
    if (size < elementData.length) {
        elementData = Arrays.copyOf(elementData, size);
    }
}

{% endhighlight %}

如果可用内存少，那还是数组就更适合。因为链表的每个节点都要消耗额外的空间去存储指针，而且频繁的插入删除等操作会导致频繁的内存申请和释放，更容易造成内存碎片。


## 应用

### 实现LRU缓存淘汰算法
----

如何用链表实现LRU缓存淘汰策略？

> 缓存是一种提高数据读取性能的技术，应用非常的广泛。缓存的大小是有限的，当内存被占用满时，哪些数据需要保留，哪些需要被清除，这就需要一个缓存的淘汰策略。常见的策略有三种：先进先出FIFO（First in First out）、最少使用LFU（Least Frequently Used）、最少使用策略LRU（Least Recently Used）。

思路：维护一个有序的单链表，越靠近尾部的节点就是越早之前访问的，当有一个新的数据开始访问的时候，我们从链表头开始遍历：

> 1）如果数据已经缓存在链表里了，那么得到这个节点之后，就把该节点从原来的位置删除，并且放在链表头部。
> 2）如果该数据没有缓存在链表里面那么又是两种情况：
>   * 如果此时缓存满了，那么把尾节点删除，插入头部
>   * 如果没满，直接插入头部

伪代码实现：

{% highlight java%}
/*
链表头节点：linked
中间节点：p、temp
当前缓存大小：curMem
最大缓存大小：maxMex
*/
node find(int s){
    for(int i=0;i<curMem;i++){ 
        if(p.next.data == s){ //如果已经存在节点了
            temp = p.next;
            p.next = temp.next;
            linked = temp;
            return linked;
        }
        else{
            p=p.next;
        }
    }
    return null;
}

void insert(node temp){
    if(curMem==maxMem){
        release(tail); //释放尾节点
    }
    temp.next = linked;
}

{% endhighlight %}


### 回文字符串

如果一个字符串是通过单链表存储的，我们该如何判断是一个回文串呢？

[234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description/)

思路：可以设置两个指针，一个快指针fast，一个慢指针slow，fast每次跳两个节点，slow每次跳一个节点，并且改变next指向的位置。当fast访问到最后节点的时候，slow刚好在中间。

伪代码实现：

{% highlight java%}



{% endhighlight %}




