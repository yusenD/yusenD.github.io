---
layout: post
title: 算法————数组
feature-img: "assets/img/background/pexels-photo8.jpeg"
thumbnail: "assets/img/background/pexels-photo8.jpeg"
tags: [算法,面试]
---

> 记忆是一种相聚的方式， <br>
> 忘却是一种自由的方式。                          
> <p align="right">——纪伯伦</p>

从一个问题开始，在很多高级语言里，数组的是从0开始开始编号，这是为什么呢？

### 1.随机访问
----


**数组（Array）是一种线性表数据结构。他用一组连续的内存空间，来存储一组具有相同类型的数据。**

这里面有几个关键词。

**线性表：**顾名思义，线性表就是一条线一样的结构。数组、链表、队列、栈等都是线性表。

![](https://i.loli.net/2018/10/02/5bb38a32182e9.jpg)

与之相对的是**非线性表**，比如二叉树、堆、图等，数据之间的关系并不是简单的前后关系。

![](https://i.loli.net/2018/10/02/5bb38a9beab71.jpg)

**连续的内存空间与相同类型的数据**，这一特性是的数组具有了“随机访问”，我们可以轻松访问到数组里面任意位置的数据。

但是，这一特性也使得很多操作变得低效繁琐。比如，如果要进行删除、插入一个数据的话，很多情况要进行大量的数据迁移工作。比如在一个数组中间插入一个数据，那这个位置后面的数据都要往后移动，删除也是如此。

首先看一下插入操作吧。加入是插入到数组最后一个位置，那时间复杂度是O(1)，如果是插入到开头，数组的n个数据都要往后移动，时间复杂度是O(n)。如此，平均时间复杂度就是：$$\frac{1}{n} + 2\frac{1}{n} + ···· + n\frac{1}{n}$$ ，即O(n)。 
然后再看一下删除操作。如果要求数据连续，那么复杂度分析和上面的插入操作一样。实际上，在某些特殊情况下，我们不一定要求数组中数据的连续性。如果我们将多次删除操作一起执行，删除的效率就高了很多。

比如下面的这个例子🌰：

我们要在数组中删除a、b、c三个元素，为了避免后面的元素多次不必要的移动，所以我们可以记录下已经删除的数据，每次删除数据其实并不是真正的进行删除，而且记录下数据已经被删除了。当数组没有更多的空间存储时，再进行一次真正的删除操作，这样就很大程度上减少了时间复杂度。 
其实这就是JVM标记清除垃圾回收算法的核心。

> JVM标记清除算法：大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成之后，清理工作才会开始。但是这种方式还是有所不足：一是效率问题，标记和清理的效率都不高，但是当知道只有少量垃圾产生时会很高效。二是空间问题，可能会产生不连续的内存空间碎片。

> *面试的时候一个经常会问到的问题：数组和链表的区别*这里总结一下：
> 
> ![](https://i.loli.net/2018/10/02/5bb38ca19fbff.jpg)
> 


### 2.警惕数组越界
----


先给出数组的寻址公式：

> a[k]_address = base_address + k*data_type_size //data_type_size表示数组中每个元素的大小

这里有一段代码：

```
int main(){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

```

很简单的代码，最后的输出结果是无线打印“hello world”，原因在于数组越界了。arr[3]访问的实际上是i，所以i变成了0。在C语言中，只要不是访问受限的内存，所有内存空间都是可以自由访问的。函数体内部的局部变量存在栈上，而且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。

数组越界在C语言中是一种未决的行为，并且没有规定数组访问越界时候编译器应该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可以用的，那么程序可能不会报任何错误。

但是其实，很多语言本身会做越界检查，比如Java的`ArryIndexOutOfBounds`的异常。

### 3.解答开篇


为什么从0开始编号，而不是从1呢？

上面给出了一个寻址公式，a[0]即偏移量为0，即首地址，如果规定a[1]的偏移量为0，那么寻址公式就变成了

> a[k]_address = base_address + (k-1)*data_type_size

这样每次都多了一次减法运算，得不偿失。


对于m*n的数组，寻址公式为：
> a[i][j]_address = base_address + (i*n+j)*data_type_size


   








