---
layout: post
title: 算法————排序
feature-img: "assets/img/background/pexels-photo12.jpeg"
tags: [算法,面试]
---

> 轻纱暧脉万点波， <br>
> 水迷湖渺一瞬情。                          
> <p align="right">——《谷中雨》</p>

<br>
* TOC 
{:toc}


## 简介
----
排序算法有很多。其中最常用的：冒泡排序、插入排序、归并排序、快速排序、基数排序、桶排序等。

这里按照时间复杂分一下类：

排序算法 | 时间复杂度 | 是否基于比较
冒泡、插入、选择 | $$O(n^2)$$ | ✅
快排、归并 | $$O(nlogn)$$ | ✅
桶、计数、基数 | $$O(n)$$ | ❌

### 怎么分析一个排序算法

会写还是不够的，我们还得会如何分析、评价一个排序算法。

#### 1.执行效率

* 最好情况、最坏情况、平均情况时间复杂度。
* 时间复杂度的系数、常数、阶数。
* 比较次数和交换（移动）次数。

#### 2.排序算法的内存消耗

空间复杂度还是要好好考虑一下的，这里引入一个新的概念**原地排序（sorted in place）**，就是特指空间复杂度为$$O(1)$$的排序算法，上面表格的第一行就都是原地排序算法。

#### 3.稳定性

稳定性，即用算法对一组数据进行排序之后，相等元素原有的先后顺序不变。

在实际的软件开发时，要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个值对对象进行排序，如果算法不稳定的话，可能会出问题。

比如这个需求：有一堆订单，是按照下单顺序进行排序的排序的，我们现在需要按照金额排序，同时相同金额的订单要按照下单顺序排序。这样就必须要稳定的排序算法了。

## 算法详解

### 1.冒泡排序
----
可能是最简单的排序算法了。假如要把数据从小到大进行排列，那么把整个数组竖起来，从最底部开始进行比较，如果第一个比第二个大，那么这两个元素交换位置，然后第二个和第三个比较，以此类推，一直到最后。大数像是水里的泡泡一样，往上冒。

第一次这样的循环，使得数组的最后一个元素是整个数组中最大的元素。然后进行第二次循环，还是从第一个开始，由于此时最后一个元素已经有序，所以只需要检测到倒数第二个即可。第三次同理，最后两个元素已经有序，只需要检测到倒数第三个元素。

#### 代码：

{% highlight java%}

public void BubbleSort() {
        int[] sortNum = this.num;
        for (int i = 0; i < sortNum.length; i++) {
            for (int j = 0; j < sortNum.length - i - 1; j++) {
                if (sortNum[j + 1] < sortNum[j]) {
                    int temp = sortNum[j];
                    sortNum[j] = sortNum[j + 1];
                    sortNum[j + 1] = temp;
                }
            }
        }
        output(sortNum);
    }
    
{% endhighlight %}

上面的代码我第一次写的时候发现结果不对，然后检查了一会儿才发现问题：在第二个for循环，应该是每次都要从0位置开始。我最开始写条件的是`j=i;j<sortNum.length-1;j++`，这样的问题其实就是冒泡冒反了= =

算法是可以继续优化的，如果没有循环过程发现，没有进行数据交换了，那么这说明数组已经有序了，可以直接跳出了。

优化代码：

{% highlight java%}
public void BubbleSort() {
        int[] sortNum = this.num;
        boolean flag = false;
        for (int i = 0; i < sortNum.length; i++) {
            for (int j = 0; j < sortNum.length - i - 1; j++) {
                if (sortNum[j + 1] < sortNum[j]) {
                    int temp = sortNum[j];
                    sortNum[j] = sortNum[j + 1];
                    sortNum[j + 1] = temp;
                    flag = true;
                }
            }
            if(!flag) break;  //说明flag = false，此次循环没有发生数据交换。
            flag = !flag;

        }
        output(sortNum);
    }

    public void BubbleSortRe() {
        int[] sortNum = this.num;
        for (int i = 0; i < sortNum.length; i++) {
            for (int j = 0; j < sortNum.length - i - 1; j++) {
                if (sortNum[j + 1] > sortNum[j]) {
                    int temp = sortNum[j];
                    sortNum[j] = sortNum[j + 1];
                    sortNum[j + 1] = temp;
                    flag = true;
                }
            }
            if(!flag) break;  //说明flag = false，此次循环没有发生数据交换。
            flag = !flag;
        }
        output(sortNum);
    }
{% endhighlight %}

#### 分析

三个问题：
* 冒泡排序是原地排序算法吗？

答：冒泡排序过程中，只用到了一个temp临时空间，用于交换数据，所以空间复杂度为$$O(1)$$，所以是原地排序算法。

* 冒泡排序是稳定的排序算法吗？

答：冒泡排序过程中，改变两个元素的前后顺序的操作只有交换，而我们在元素相等的时候不交换，所以冒泡排序是稳定的算法。

* 时间复杂度？

答：最好情况复杂度：如果数组本身已经是有序的了，那么我们只需要一次冒泡操作就可以了，时间复杂度为$$O(n)$$。最坏时间复杂度：数组本身是倒序的，那么需要n次冒泡操作，所以最坏的情况复杂度是$$O(n^2)$$。

平均情况复杂度：这个有点复杂，需要单独拿出来说。这里引入两个概念：**有序度**和**逆序度**。

有序度就是数组里面的有序数对的个数，比如一个倒序排列的数组，那么有序度就为0；对于一个完全有序的数组，有序度就为$$n*(n-1)/2$$，这种完全有序的数组的有序度叫做满有序度。

逆序度和有序度完全相反，有公式：**逆序度 = 满有序度 - 有序度**。

冒泡排序每进行一次交换操作，那么有序度加一，逆序度减一。知道有序度满，数组有序。

最后平均时间复杂度也为$$O(n^2)$$


### 2.插入排序
----
在一个有序的数组里面再插入一个数据，我们如何保证该数组还是有序的呢？我们只要遍历数组，找到对应的位置进行插入就可以了。

插入排序算法就是利用上面的思想。把数组分为有序区和无序区，从无序区取一个数字，插入到有序区，直到无序区为空。

因为插入需要移动数组，所以在移动的时候最好倒着遍历，向前移动行不通，只能是向后移动，用一个临时变量保存比较的数值，就有了可以移动的位置。

#### 代码

{% highlight java%}

public void InsertSort() {
        int[] sortNum = this.num;
        for (int i = 1; i < sortNum.length; i++) {
            int temp = sortNum[i];
            int j = i-1;
            for (; j >= 0; j--) {   //从后向前遍历，方便移动
                if (sortNum[j] > temp) {
                    sortNum[j + 1] = sortNum[j];
                }else   {
                    break;
                }
            }
            sortNum[j+1] = temp;

        }
        output(sortNum);
    }

    public void InsertSortRe() {
        int[] sortNum = this.num;
        for (int i = 1; i < sortNum.length; i++) {
            int temp = sortNum[i];
            int j = i-1;
            for (;j>=0;j--){
                if (sortNum[j] < temp) {
                    sortNum[j+1] = sortNum[j];
                }else {
                    break;
                }
            }
            sortNum[j+1] = temp;
        }
        output(sortNum);
    }

{% endhighlight %}

#### 分析：

三个问题：

* 插入排序是原地排序算法吗？

答：是，空间复杂度为$$O(1)$$

* 插入排序是稳定的吗？

答：是，显然，以顺序为例（从小到大），插入的元素如果遇到比它大的元素就插入在它的前面，并且移动元素，否则，说明已经找到了正确位置，跳出本次循环。故不会改变相等元素的相对位置。

* 时间复杂度？

答：最好时间复杂度：本身就是顺序的，所以不用移动元素，只需要$$O(n)$$。最坏情况时间复杂度：数据是倒序的，每个数据都需要进行移动，时间复杂度为$$O(n^2)$$。平均时间复杂度：$$O(n^2)$$

### 3.选择排序
----
选择排序算法的思路和插入排序类似，也分为有序区和无序区，不同的是，选择排序是每次从无序区选择一个最小的元素，放在有序区的后面（具体实现是无序区的第一个元素和最小元素位置交换）。

#### 代码

{% highlight java%}

public void SelectSortRe() {
        int[] sortNum = this.num;
        for (int i = 0; i < sortNum.length; i++) {
            int max = i;
            for (int j = i+1; j < sortNum.length; j++) {
                if (sortNum[j] > sortNum[max]) {
                    max = j;
                }
            }
            int temp = sortNum[i];
            sortNum[i] = sortNum[max];
            sortNum[max] = temp;
        }
        output(sortNum);
    }

    public void SelectSort() {
        int[] sortNum = this.num;
        for (int i = 0; i < sortNum.length; i++) {
            int min = i;
            for (int j = i+1; j < sortNum.length; j++) {
                if (sortNum[j] < sortNum[min]) {
                    min = j;
                }
            }
            int temp = sortNum[i];
            sortNum[i] = sortNum[min];
            sortNum[min] = temp;
        }
        output(sortNum);
    }


{% endhighlight %}

#### 分析

问题同上

* 是原地排序
* 不稳定，因为我们在排序过程中，使用了交换操作，这改变了原来数组元素的位置。
* 最好、最坏、平均时间复杂度均为$$O(n^2)$$

由此也可以看出，相较于冒泡和插入，选择排序显得逊色了不少。


### 以上三种算法总结和拓展
----

> 插入和冒泡的时间复杂度相同，但是在实际开发中，我们更倾向于使用插入排序算法。
> 
> 原因在于，冒泡排序和插入排序，不管怎么优化，元素的移动次数等于数组的逆序度，但是从代码实现上来看：
> 
{% highlight java%}

冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}

{% endhighlight %}
>
>可以看到，冒泡排序的数据交换要比插入排序的数据移动要复杂不少。10w条数据进行排序的耗费时间对比显示，插入排序比冒泡排序快了很多很多。

#### 希尔排序

//等待填坑



### 4.归并排序
----


### 5.快速排序
----


