---
layout: post
title: 算法————排序
feature-img: "assets/img/background/pexels-photo12.jpeg"
tags: [算法,面试]
---

> 轻纱暧脉万点波， <br>
> 水迷湖渺一瞬情。                          
> <p align="right">——《谷中雨》</p>

<br>
* TOC 
{:toc}


## 简介
----
排序算法有很多。其中最常用的：冒泡排序、插入排序、归并排序、快速排序、基数排序、桶排序等。

这里按照时间复杂分一下类：

排序算法 | 时间复杂度 | 是否基于比较
冒泡、插入、选择 | $$O(n^2)$$ | ✅
快排、归并 | $$O(nlogn)$$ | ✅
桶、计数、基数 | $$O(n)$$ | ❌

### 怎么分析一个排序算法

会写还是不够的，我们还得会如何分析、评价一个排序算法。

#### 1.执行效率

* 最好情况、最坏情况、平均情况时间复杂度。
* 时间复杂度的系数、常数、阶数。
* 比较次数和交换（移动）次数。

#### 2.排序算法的内存消耗

空间复杂度还是要好好考虑一下的，这里引入一个新的概念**原地排序（sorted in place）**，就是特指空间复杂度为$$O(1)$$的排序算法，上面表格的第一行就都是原地排序算法。

#### 3.稳定性

稳定性，即用算法对一组数据进行排序之后，相等元素原有的先后顺序不变。

在实际的软件开发时，要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个值对对象进行排序，如果算法不稳定的话，可能会出问题。

比如这个需求：有一堆订单，是按照下单顺序进行排序的排序的，我们现在需要按照金额排序，同时相同金额的订单要按照下单顺序排序。这样就必须要稳定的排序算法了。

## 算法详解

### 1.冒泡排序

可能是最简单的排序算法了。假如要把数据从小到大进行排列，那么把整个数组竖起来，从最底部开始进行比较，如果第一个比第二个大，那么这两个元素交换位置，然后第二个和第三个比较，以此类推，一直到最后。大数像是水里的泡泡一样，往上冒。

第一次这样的循环，使得数组的最后一个元素是整个数组中最大的元素。然后进行第二次循环，还是从第一个开始，由于此时最后一个元素已经有序，所以只需要检测到倒数第二个即可。第三次同理，最后两个元素已经有序，只需要检测到倒数第三个元素。

代码：
{% highlight java%}

public void BubbleSort() {
        int[] sortNum = this.num;
        for (int i = 0; i < sortNum.length; i++) {
            for (int j = 0; j < sortNum.length - i - 1; j++) {
                if (sortNum[j + 1] < sortNum[j]) {
                    int temp = sortNum[j];
                    sortNum[j] = sortNum[j + 1];
                    sortNum[j + 1] = temp;
                }
            }
        }
        output(sortNum);
    }
    
{% endhighlight %}

上面的代码我第一次写的时候发现结果不对，然后检查了一会儿才发现问题：在第二个for循环，应该是每次都要从0位置开始。我最开始写条件的是`j=i;j<sortNum.length-1;j++`，这样的问题其实就是冒泡冒反了= =

算法是可以继续优化的，如果没有循环过程发现，没有进行数据交换了，那么这说明数组已经有序了，可以直接跳出了。

优化代码：

{% highlight java%}
public void BubbleSort() {
        int[] sortNum = this.num;
        boolean flag = false;
        for (int i = 0; i < sortNum.length; i++) {
            for (int j = 0; j < sortNum.length - i - 1; j++) {
                if (sortNum[j + 1] < sortNum[j]) {
                    int temp = sortNum[j];
                    sortNum[j] = sortNum[j + 1];
                    sortNum[j + 1] = temp;
                    flag = true;
                }
            }
            if(!flag) break;  //说明flag = false，此次循环没有发生数据交换。
            flag = !flag;

        }
        output(sortNum);
    }

    public void BubbleSortRe() {
        int[] sortNum = this.num;
        for (int i = 0; i < sortNum.length; i++) {
            for (int j = 0; j < sortNum.length - i - 1; j++) {
                if (sortNum[j + 1] > sortNum[j]) {
                    int temp = sortNum[j];
                    sortNum[j] = sortNum[j + 1];
                    sortNum[j + 1] = temp;
                    flag = true;
                }
            }
            if(!flag) break;  //说明flag = false，此次循环没有发生数据交换。
            flag = !flag;
        }
        output(sortNum);
    }
{% endhighlight %}


### 2.插入排序

### 3.选择排序

### 4.归并排序

### 5.快速排序

