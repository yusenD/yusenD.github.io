---
layout: post
title: 算法————复杂度（上）
feature-img: "assets/img/background/pexels-photo1.jpeg"
thumbnail: "assets/img/background/pexels-photo1.jpeg"
tags: [算法,面试]
---

> 芦叶满汀洲，寒沙带浅流。二十年重到南楼。柳下系船犹未稳，能几日，又中秋。 <br>
> 黄鹤断矶头，故人今在否。旧江山浑是新愁。欲买桂花重载酒，终不似，少年游。                          
> <p align="right">——刘过《唐多令》</p>

<br><br>

研究数据结构和算法是为了“快”和“省”的问题，即如何让代码运行的更快，如何让代码运行的更加节省空间。所以为了衡量算法的运行效率，我们引入了**时间复杂度、空间复杂度**的概念。这两个概念**十分重要**，贯穿着整个数据结构和算法知识。

----

**大O复杂度表示法**：算法的执行效率，粗略的讲，就是算法执行的时间。大O时间复杂度实际上并不代表代码的真正执行时间，而是代表**代码执行时间随数据规模增长的变化趋势**，所以也叫做**渐进时间复杂度**，简称时间复杂度

### 时间复杂度分析
----

有一些方法来帮助进行分析。

#### 1.只关注执行次数最多的一段代码

大O这种复杂度表示方法只是表示一种变化趋势。通常会忽视常数、系数和低阶的数，只记录最大阶。

#### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

举个例子🌰：

```
int main(){
    for(int i=0;i<100;i++){
        //DoSomeThing
    }
    for(int j=0;j<100;j++){
        //DoSomeThing
    }
    for(int k=0;k<100;k++){
        for(int h=0;h<100;h++){
        //DoSomeThing
        }
    }
    return 0;
}
```

很明显了 $$ T(n) = O(n^2) $$

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

这个也很好理解，举个例子🌰：

```
int countSth(int j){
    int sum;
    for(int i=0;i<j;i++){
        sum+=i;
    }
    return sum;
}

int main(){
    int sum;
    for(int i=0;i<10;i++){
        sum+=countSth(i);
    }
    return 0;
}
```

上面的，`countSth`的时间复杂度$$T(n1)=O(n)$$，那下面的就是$$ T(n)=T(n1)*T(n2)=O(n*n)=O(n^2)$$

----
以上，这些方法不用死记硬背，理解即可，因为越算越熟练。

### 常见的时间复杂度分析：
----
可以粗略地分为两类：
* 多项式量级：
    * 常数阶：$$ O(1)$$
    * 对数阶：$$ O(\log n)$$
    * 线性阶：$$ O(n)$$
    * 线性对数阶：$$ O(n\log n)$$
    * 平方阶：$$ O(n^2)$$、立方阶：$$ O(n^3)$$
* 非多项式量级：
    * 指数阶：$$ O(2^n)$$
    * 阶乘阶：$$ O(n!)$$

这些非多项式量级的问题叫做**NP问题**（Non-Deterministic Polynomial，非确定多项式）。当数据规模越来越大时，这种算法的执行时间会爆炸增长，时间非常的低效。

接下来看一下几种常见的多项式时间复杂度：

#### 1.$$O(1)$$

这个就很简单了，代码的执行时间不随n的增大而增大。一般情况下，只要算法中不存在**循环、递归，即使有几万行代码，时间复杂度也是$$O(1)$$**

#### 2.$$ O(\log n)$$、$$ O(n\log n)$$

十分常见的高效算法，但是分析起来最困难。

举个例子🌰：

```
i=1;
while(i<=n){
    i=i*2;
}
```

为了算出时间复杂度，要看看这个执行次数是多少。可以看到，i从1开始，每次执行一次都乘2，直到大于n停止。

所以由此得到一个公式：

    $$ 2^x = n$$

则：

    $$ x = \log_{2}n$$

时间复杂度为 $$ O(\log n)$$

至于$$ O(n\log n)$$计算方法同上，如果一个$$ O(\log n)$$执行n次，复杂度就是他了。归并排序，快速排序复杂度都是这个。

#### 3.$$O(m+n)$$、$$O(m*n)$$

这种是比较特殊的，m与n是两个数据规模，我们无法评级究竟谁的量级大，就不能简单的利用加法法则，乘法法则还是适用的。

<br>
### 空间复杂度
----

空间复杂度表示**算法的存储空间和数据规模之间的增长关系**。

举个例子🌰：

```
int[] a = new int[n];
for(int i=0;i<n;i++){
    a[i] = i*i;
}
```

我们申请了大小为n的int型数组，而其余的i什么的都是常量阶的，所以整段代码的控件复杂度是O(n).


----

最后在贴一张图：

![](https://i.loli.net/2018/09/26/5bab8f191e071.jpg)

复杂度从低到高排序如上图，大部分的算法复杂度都跑不出这几个。

**<center>多练习啦</center>**

