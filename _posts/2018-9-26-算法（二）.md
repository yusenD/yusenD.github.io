---
layout: post
title: 算法（二）
feature-img: "assets/img/background/pexels-photo5.jpeg"
thumbnail: "assets/img/background/pexels-photo5.jpeg"
tags: [算法,面试]
---

> 芦叶满汀洲，寒沙带浅流。二十年重到南楼。柳下系船犹未稳，能几日，又中秋。 <br>
> 黄鹤断矶头，故人今在否。旧江山浑是新愁。欲买桂花重载酒，终不似，少年游。                          
> <p align="right">——刘过《唐多令》</p>

<br><br>

研究数据结构和算法是为了“快”和“省”的问题，即如何让代码运行的更快，如何让代码运行的更加节省空间。所以为了衡量算法的运行效率，我们引入了**时间复杂度、空间复杂度**的概念。这两个概念**十分重要**，贯穿着整个数据结构和算法知识。

----

**大O复杂度表示法**：算法的执行效率，粗略的讲，就是算法执行的时间。大O时间复杂度实际上并不代表代码的真正执行时间，而是代表**代码执行时间随数据规模增长的变化趋势**，所以也叫做**渐进时间复杂度**，简称时间复杂度

### 时间复杂度分析
----

有一些方法来帮助进行分析。

#### 1.只关注执行次数最多的一段代码

大O这种复杂度表示方法只是表示一种变化趋势。通常会忽视常数、系数和低阶的数，只记录最大阶。

#### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

举个例子🌰：

```
int main(){
    for(int i=0;i<100;i++){
        //DoSomeThing
    }
    for(int j=0;j<100;j++){
        //DoSomeThing
    }
    for(int k=0;k<100;k++){
        for(int h=0;h<100;h++){
        //DoSomeThing
        }
    }
    return 0;
}
```

很明显了 $$ T(n) = O(n^2) $$

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

这个也很好理解，举个例子🌰：

```
int countSth(int j){
    int sum;
    for(int i=0;i<j;i++){
        sum+=i;
    }
    return sum;
}

int main(){
    int sum;
    for(int i=0;i<10;i++){
        sum+=countSth(i);
    }
    return 0;
}
```

上面的，`countSth`的时间复杂度$$T(n1)=O(n)$$，那下面的就是$$ T(n)=T(n1)*T(n2)=O(n*n)=O(n^2)$$

----
以上，这些方法不用死记硬背，理解即可，因为越算越熟练。

### 常见的时间复杂度分析：
----
可以粗略地分为两类：
* 多项式量级：
    * 常数阶：$$ O(1)$$
    * 对数阶：$$ O(\log n)$$
    * 线性阶：$$ O(n)$$
    * 线性对数阶：$$ O(n\log n)$$
    * 平方阶：$$ O(n^2)$$、立方阶：$$ O(n^3)$$
* 非多项式量级：
    * 指数阶：$$ O(2^n)$$
    * 阶乘阶：$$ O(n!)$$

这些非多项式量级的问题叫做**NP问题**（Non-Deterministic Polynomial，非确定多项式）。当数据规模越来越大时，这种算法的执行时间会爆炸增长，时间非常的低效。

接下来看一下几种常见的多项式时间复杂度：

#### 1.O(1)

这个就很简单了，代码的执行时间不随n的增大而增大。一般情况下，只要算法中不存在**循环、递归，即使有几万行代码，时间复杂度也是O(1)**

#### 2.$$ O(\log n)$$、$$ O(n\log n)$$

十分常见，但是分析起来最困难。





