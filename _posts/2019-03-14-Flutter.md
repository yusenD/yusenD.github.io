---
layout: post
title: Flutter与Native通信
feature-img: "assets/img/background/pexels-photo17.jpeg"
tags: [Android,Flutter]
---

> 永远相信美好的事情即将发生。 <br>                          
<br> 

主要对Android分析。


# Flutter

先看一张官方给出的图。Flutter与Native之间的通信主要是通过Channel完成的。下面以MethodChannel为例，深入看一下，消息究竟是怎么一步一步传送到达Native端。

![](https://i.loli.net/2019/03/16/5c8c97d9518dd.jpg)


## 1.从Flutter出发

<br>

### MethodChannel
-----

需要创建`MethodChannel`，点进`MethodChannel`看看构造方法：

{% highlight java%}

const MethodChannel(this.name, [this.codec = const StandardMethodCodec()]);

{% endhighlight %}

比较简单，传入了Name和一个可选的`MethodCodec`，这个MethodCodec是一个负责decode和encode的工具，默认使用官方提供的`StandardMethodCodec`，支持类型包括int/double等等。在Flutter，MethodChannel和EventChannel都是默认都是StandardMethodCodec，但是在Native那边，两者的codec是MethodCodec类型，这个是一个接口，然后看MethodCodec的实现类，包括了StandardMethodCodec。[这里是API文档介绍](https://docs.flutter.io/flutter/services/StandardMessageCodec-class.html)。

![](https://i.loli.net/2019/03/16/5c8c97d94b178.jpg)

<br>

### MethodChannel.invokeMethod
-----

之后，调用`invokeMethod`方法，源码可以看到还有`invokeListMethod`和`invokeMapMethod`方法这个就是返回类型不同了。

> 官方介绍里面说Dart泛型已实现，这意味着无类型列表无法伪装成List。由于invokeMethod只能返回动态映射，我们使用List.cast创建一个新的类型列表。
> **//TODO 没看明白，填坑**


{% highlight java%}

  Future<T> invokeMethod<T>(String method, [dynamic arguments]) async {
    assert(method != null);
    final ByteData result = await BinaryMessages.send(
      //唯一标识
      name,
      //封装method和args成MethodCall对象
      codec.encodeMethodCall(MethodCall(method, arguments)),
    );
    if (result == null) {
      throw MissingPluginException('No implementation found for method $method on channel $name');
    }
    final T typedResult = codec.decodeEnvelope(result);
    return typedResult;
  }

{% endhighlight %}

在这里，`BinaryMessages.send()`将消息发送出去了，结果返回给relust，result解码之后得到对应的typedResult。过程是异步的。
方法传入了`channel`，即我们创建的plugin名字，这个也是channel的标识；还传入了`ByteData`，即编码过后的MethodCall对象，里面封装了method和arguments。

接下来看看这个send方法。

> Dart和Java的异步操作还是很不同的，async和await关键字支持异步编程，允许我们编写看起来类似于同步代码的异步代码。

<br>

### BinaryMessages.send
-----

{% highlight java%}

  static Future<ByteData> send(String channel, ByteData message) {
    final _MessageHandler handler = _mockHandlers[channel];
    if (handler != null)
      return handler(message);
    return _sendPlatformMessage(channel, message);
  }

{% endhighlight %}

这里的逻辑是看_mockHandlers里面有没有这个channel，如果有的话就直接处理。这个mock是模拟，看名字我还以为是什么黑科技 = =。

其实这个是用于调试的，会被拦截，不会进一步传递到platform。

<br>

### _sendPlatformMessage
-----

{% highlight java%}

  static Future<ByteData> _sendPlatformMessage(String channel, ByteData message) {
    final Completer<ByteData> completer = Completer<ByteData>();
    //系统中的window实例，主机操作系统用户界面的最基本界面
    ui.window.sendPlatformMessage(channel, message, (ByteData reply) {
      try {
        //
        completer.complete(reply);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: 'during a platform message response callback',
        ));
      }
    });
    return completer.future;
  }

{% endhighlight %}

`Completer`是一个一种生成Future对象的方法，在这里调用了sendPlatformMessage，并且写了reply回调接口，利用complete对reply做了处理。

<br>

###  ui.window.sendPlatformMessage
-----

{% highlight java%}

  void sendPlatformMessage(String name,
                           ByteData data,
                           PlatformMessageResponseCallback callback) {
    final String error =
        _sendPlatformMessage(name, _zonedPlatformMessageResponseCallback(callback), data);
    if (error != null)
      throw new Exception(error);
  }

{% endhighlight %}

这里要注意一下传入的PlatformMessageResponseCallback，这个回调方法会在framework里面调用。

里面还是一个`_sendPlatformMessage`方法

<br>

### _sendPlatformMessage
-----

{% highlight java%}
String _sendPlatformMessage(String name,
                              PlatformMessageResponseCallback callback,
                              ByteData data) native 'Window_sendPlatformMessage';
{% endhighlight %}

看到了native，说明是时候去找native层了，对应Window_sendPlatformMessage，其实也可以利用Github看源码。

<br>

### window.cc Window_sendPlatformMessage
-----

{% highlight java%}
 {"Window_sendPlatformMessage", _SendPlatformMessage, 4, true}
 
 void _SendPlatformMessage(Dart_NativeArguments args) {
  tonic::DartCallStatic(&SendPlatformMessage, args);
}

Dart_Handle SendPlatformMessage(Dart_Handle window,
                                const std::string& name,
                                Dart_Handle callback,
                                Dart_Handle data_handle) {
  UIDartState* dart_state = UIDartState::Current();

  if (!dart_state->window()) {
    return tonic::ToDart(
        //main isolate调用Platform方法
        "Platform messages can only be sent from the main isolate");
  }

  fml::RefPtr<PlatformMessageResponse> response;
  if (!Dart_IsNull(callback)) {
    //如果有callback的话，去获取response
    response = fml::MakeRefCounted<PlatformMessageResponseDart>(
        tonic::DartPersistentValue(dart_state, callback),
        dart_state->GetTaskRunners().GetUITaskRunner());
  }
  if (Dart_IsNull(data_handle)) {
    dart_state->window()->client()->HandlePlatformMessage(
        fml::MakeRefCounted<PlatformMessage>(name, response));
  } else {
    tonic::DartByteData data(data_handle);
    const uint8_t* buffer = static_cast<const uint8_t*>(data.data());
    dart_state->window()->client()->HandlePlatformMessage(
        fml::MakeRefCounted<PlatformMessage>(
            name, std::vector<uint8_t>(buffer, buffer + data.length_in_bytes()),
            response));
  }

  return Dart_Null();
}
 
{% endhighlight %}

在 engine/lib/ui/window/window.cc 里面可以找到SendPlatformMessage。

这里有一点，`"Platform messages can only be sent from the main isolate"` 嗯，可以的。

可以看到，从dart_state到window到client最后是`HandlePlatformMessage`，来找找这个方法。

这个dart_state是一个`UIDartState`类，window不用说，client是一个`WindowClient`类，然后RuntimeController继承了这个类.

<br>

### RuntimeController.cc HandlePlatformMessage
-----

{% highlight java%}

void RuntimeController::HandlePlatformMessage(
    fml::RefPtr<PlatformMessage> message) {
  client_.HandlePlatformMessage(std::move(message));
}

{% endhighlight %}

这个client_在头文件里面可以看到，是个`RuntimeDelegate`，再去看看这个，里面的HandlePlatformMessage也是虚函数。Engine实现了Delegate，这里提一下，看着像是委托模式，好处是可以把消息等交给delegate去处理不同平台，代码复用，上层不用担心。

<br>

### engine.cc HandlePlatformMessage
-----

{% highlight java%}

void Engine::HandlePlatformMessage(
    fml::RefPtr<blink::PlatformMessage> message) {
  if (message->channel() == kAssetChannel) {
    //如果是kAssetChannel的话，说明想要获取asset资源，调用对应方法
    HandleAssetPlatformMessage(std::move(message));
  } else {
    delegate_.OnEngineHandlePlatformMessage(std::move(message));
  }
}

{% endhighlight %}

这个方法检测是不是Flutter获取的平台信息，如果是的话，就转这个逻辑，不是的话就交给delegate。这里的delegate实现Shell

<br>

### shell.cc OnEngineHandlePlatformMessage
-----

{% highlight java%}

// |shell::Engine::Delegate|
void Shell::OnEngineHandlePlatformMessage(
    fml::RefPtr<blink::PlatformMessage> message) {
  FML_DCHECK(is_setup_);
  FML_DCHECK(task_runners_.GetUITaskRunner()->RunsTasksOnCurrentThread());
  //消息类型是kSkiaChannel。这个不清楚 flutter/skia ？
  if (message->channel() == kSkiaChannel) {
    HandleEngineSkiaMessage(std::move(message));
    return;
  }
  // 向PlatformTaskRunner 添加Task
  task_runners_.GetPlatformTaskRunner()->PostTask(
      [view = platform_view_->GetWeakPtr(), message = std::move(message)]() {
        if (view) {
          view->HandlePlatformMessage(std::move(message));
        }
      });
}

{% endhighlight %}

可以看到，在Shell类里，会在PlatformTaskRunner中添加一个task，这时候执行会切换到Platform task，之前都是在UI task中执行的。PlatformView的HandlePlatformMessage是一个虚函数，PlatformViewAndroid和iOS都对其进行了实现。以Android为例。


<br>
### platform_view_android.cc HandlePlatformMessage
-----

{% highlight java%}

// |shell::PlatformView|
void PlatformViewAndroid::HandlePlatformMessage(
    fml::RefPtr<blink::PlatformMessage> message) {
  JNIEnv* env = fml::jni::AttachCurrentThread();
  fml::jni::ScopedJavaLocalRef<jobject> view = java_object_.get(env);
  if (view.is_null())
    return;

  int response_id = 0;
  if (auto response = message->response()) {
    //如果message里面有response的话，response_id是自增并且以这个值为key加入pending_responses_，后面会根据id来取出response
    response_id = next_response_id_++;
    pending_responses_[response_id] = response;
  }
  //数据格式转换成Java可以识别的
  auto java_channel = fml::jni::StringToJavaString(env, message->channel());
  if (message->hasData()) {
    fml::jni::ScopedJavaLocalRef<jbyteArray> message_array(
        env, env->NewByteArray(message->data().size()));
    env->SetByteArrayRegion(
        message_array.obj(), 0, message->data().size(),
        reinterpret_cast<const jbyte*>(message->data().data()));
    message = nullptr;

    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.
    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),
                                     message_array.obj(), response_id);
  } else {
    message = nullptr;

    // This call can re-enter in InvokePlatformMessageXxxResponseCallback.
    FlutterViewHandlePlatformMessage(env, view.obj(), java_channel.obj(),
                                     nullptr, response_id);
  }
}


{% endhighlight %}

可以看到，已经开始JNI方法了。通过`message->channel()`获取了channel，msg为空就传个空指针，通过`FlutterViewHandlePlatformMessage`发起调用。

这里有一个`response_id`，初始值是0，是一个自增的，后面的`pending_responses_`以这个值为key，存入了`response`，

<br>

### platform_view_android_jni.cc FlutterViewHandlePlatformMessage
-----
{% highlight java%}

void FlutterViewHandlePlatformMessage(JNIEnv* env,
                                      jobject obj,
                                      jstring channel,
                                      jobject message,
                                      jint responseId) {
  env->CallVoidMethod(obj, g_handle_platform_message_method, channel, message,
                      responseId);
  FML_CHECK(CheckException(env));
}

  g_handle_platform_message_method =
      env->GetMethodID(g_flutter_jni_class->obj(), "handlePlatformMessage",
                       "(Ljava/lang/String;[BI)V");

  if (g_handle_platform_message_method == nullptr) {
    FML_LOG(ERROR) << "Could not locate handlePlatformMessage method";
    return false;
  }

{% endhighlight %}

env调用Java方法。看到了这个`g_handle_platform_message_method`就差不多，调用了`FlutterJNI`的handlePlatformMessage

<br>


<br>

### FlutterJNI/FlutterNativeView handlePlatformMessage
-----

通过`FlutterJNI`，然后找到了`FlutterNativeView`中的实现（该类是`BinaryMessenger`的实现类），终于回到了熟悉的Java。这个`FlutterJNI`感觉类似于一个中间层，建立了Java和Native的联系，在`FlutterNativeView`中要对jni进行attach，并且在方法中会判断是否attach，调用`destroy()`可以在方法里面执行jni断开连接的操作。

首先看一下`FlutterNativeView`里面都有啥。

{% highlight java%}

public FlutterNativeView(Context context, boolean isBackgroundView) {
        this.mNextReplyId = 1;
        this.mPendingReplies = new HashMap();
        this.mContext = context;
        this.mPluginRegistry = new FlutterPluginRegistry(this, context);
        //创建了JNI哦
        this.mFlutterJNI = new FlutterJNI();
        this.mFlutterJNI.setRenderSurface(new FlutterNativeView.RenderSurfaceImpl());
        //调用了jni的方法来设置这个handler，也就是下面的handler
        this.mFlutterJNI.setPlatformMessageHandler(new FlutterNativeView.PlatformMessageHandlerImpl());
        //监听engine层
        this.mFlutterJNI.addEngineLifecycleListener(new FlutterNativeView.EngineLifecycleListenerImpl());
        //调用的是FlutterJNI的方法，建立了连接，然后FlutterJNI会调用native方法，并且返回一个attachID，由FlutterJNI持有，根据这个判断当前是否保持着连接
        this.attach(this, isBackgroundView);
        this.assertAttached();
        //可以看到，这个是一个Handler的hashmap，key为channel name，value为handler，可以通过setMessageHandlers方法来添加Handler，如果handler的值为null的话，就表示移除对应channel的handler
        this.mMessageHandlers = new HashMap();
    }

{% endhighlight %}

找到这个

{% highlight java%}

    private final class PlatformMessageHandlerImpl implements PlatformMessageHandler {
        private PlatformMessageHandlerImpl() {
        }
        // 注意这三个参数，replyId用于Java写回Native过程中用
        public void handleMessageFromDart(final String channel, byte[] message, final int replyId) {
            FlutterNativeView.this.assertAttached();
            //首先根据channel name 取出对应的handler
            BinaryMessageHandler handler = (BinaryMessageHandler)FlutterNativeView.this.mMessageHandlers.get(channel);
            if (handler != null) {
                try {
                    ByteBuffer buffer = message == null ? null : ByteBuffer.wrap(message);
                    //执行handler的onMessage方法，传入了msg的buffer和一个回调
                    handler.onMessage(buffer, new BinaryReply() {
                        //并发安全类
                        private final AtomicBoolean done = new AtomicBoolean(false);
                        //对传入的ByterBuffer类型的reply进行处理，最后调用jni方法返回响应数据
                        public void reply(ByteBuffer reply) {
                            if (!FlutterNativeView.this.isAttached()) {
                                Log.d("FlutterNativeView", "handleMessageFromDart replying ot a detached view, channel=" + channel);
                            } else if (this.done.getAndSet(true)) {
                                //确保不重复提交
                                throw new IllegalStateException("Reply already submitted");
                            } else {
                                if (reply == null) {    
                                    FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
                                } else {   
                                    FlutterNativeView.this.mFlutterJNI.invokePlatformMessageResponseCallback(replyId, reply, reply.position());
                                }
                            }
                        }
                    });
                } catch (Exception var6) {
                    Log.e("FlutterNativeView", "Uncaught exception in binary message listener", var6);
                    FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
                }
            } else {
                FlutterNativeView.this.mFlutterJNI.invokePlatformMessageEmptyResponseCallback(replyId);
            }
        }

{% endhighlight %}

里面看到了handler.onMessage，这个看一下。

在这一步里还用到了`AtomicBoolean`，是处于线程安全的考虑。

还有一些点在注释里面写了不再赘述。

<br>

### IncomingMethodCallHandler onMessage
-----

这个接口有三个实现，分别对应了三个Channel。他们的区别一会儿再说，先看我们的`MethodChannel`里面的`IncomingMethodCallHandler`实现。

{% highlight java%}

        public void onMessage(ByteBuffer message, final BinaryReply reply) {
            //解码获取MethodCall对象
            MethodCall call = MethodChannel.this.codec.decodeMethodCall(message);

            try {
                //这里就是Native测的回调方法咯
                this.handler.onMethodCall(call, new MethodChannel.Result() {
                    //这不就是success方法吗！
                    public void success(Object result) {
                        //返回结果，对result编码，然后就reply
                        reply.reply(MethodChannel.this.codec.encodeSuccessEnvelope(result));
                    }

                    public void error(String errorCode, String errorMessage, Object errorDetails) {
                     //这不就是error方法吗！错误传的信息多一点
                        reply.reply(MethodChannel.this.codec.encodeErrorEnvelope(errorCode, errorMessage, errorDetails));
                    }
                    
                    public void notImplemented() {
                        reply.reply((ByteBuffer)null);
                    }
                });
            } catch (RuntimeException var5) {
                Log.e("MethodChannel#" + MethodChannel.this.name, "Failed to handle method call", var5);
                reply.reply(MethodChannel.this.codec.encodeErrorEnvelope("error", var5.getMessage(), (Object)null));
            }

        }

{% endhighlight %}

好的，`onMethodCall`，这个就是我们在Native里面的出现了！

现在切回Native里面看看。

Native接受消息，需要一个`MethodChannel`对象，并且设置Handler。

<br>

### MethodChannel onMethodCall
-----

{% highlight java%}
new MethodChannel(flutterView,FLUTTER_TO_NATIVE_CHANNEL).setMethodCallHandler(new MethodChannel.MethodCallHandler(){

    @Override
            public void onMethodCall(MethodCall methodCall, MethodChannel.Result result){
                switch(methodCall.method){
                    case:
                        ......
                        reply.success(....);
                        break;
                }
            }

})
{% endhighlight %}


点进`MethodChannel`看看构造方法：

{% highlight java%}

    public MethodChannel(BinaryMessenger messenger, String name) {
        this(messenger, name, StandardMethodCodec.INSTANCE);
    }

    public MethodChannel(BinaryMessenger messenger, String name, MethodCodec codec) {}

{% endhighlight %}

还是比较简单的，传入`BinartMessenger`（`FlutterView`实现了`BinartMessenger`）和`plugin name`，或者`MethodCodec`对象，与Flutter一样的。


然后再看`setMethodCallHandler`：

{% highlight java%}

    public void setMethodCallHandler(@Nullable MethodChannel.MethodCallHandler handler) {
        this.messenger.setMessageHandler(this.name, handler == null ? null : new MethodChannel.IncomingMethodCallHandler(handler));
    }

{% endhighlight %}

最后传入的其实是`IncomingMethodCallHandler`，也就是上面的Flutter提到的那个类。

到目前为止，Flutter传递到Native，整个流程就走完了，然后就是response了.


<br>

## 2.从Native返回


消息回复的话，调用了reply方法，最后回到了`FlutterNativeView`的`onMessage`方法，我们从`invokePlatformMessageResponseCallback`这个方法开始看吧，。


<br>

### FlutterJNI invokePlatformMessageResponseCallback
-----

{% highlight java%}

@UiThread
    public void invokePlatformMessageResponseCallback(int responseId, ByteBuffer message, int position) {
        this.ensureAttachedToNative();
        this.nativeInvokePlatformMessageResponseCallback(this.nativePlatformViewId, responseId, message, position);
    }

    private native void nativeInvokePlatformMessageResponseCallback(long var1, int var3, ByteBuffer var4, int var5);

{% endhighlight %}

里面调用了native方法，接下来去native层。


<br>

### platform_view_android_jni.cc invokePlatformMessageResponseCallback
-----

{% highlight java%}

      {
          .name = "nativeInvokePlatformMessageResponseCallback",
          .signature = "(JILjava/nio/ByteBuffer;I)V",
          .fnPtr = reinterpret_cast<void*>(
              &shell::InvokePlatformMessageResponseCallback),
      },
      
      static void InvokePlatformMessageResponseCallback(JNIEnv* env,
                                                  jobject jcaller,
                                                  jlong shell_holder,
                                                  jint responseId,
                                                  jobject message,
                                                  jint position) {
  ANDROID_SHELL_HOLDER->GetPlatformView()
      ->InvokePlatformMessageResponseCallback(env,         //
                                              responseId,  //
                                              message,     //
                                              position     //
      );
}

{% endhighlight %}

可以看到调用了`PlatformView`的`InvokePlatformMessageResponseCallback`，去看看吧。

<br>

### InvokePlatformMessageResponseCallback
------

{% highlight java%}

void PlatformViewAndroid::InvokePlatformMessageResponseCallback(
    JNIEnv* env,
    jint response_id,
    jobject java_response_data,
    jint java_response_position) {
  if (!response_id)
    return;
  //这里需要注意，可以看到用response_id来取出了response
  auto it = pending_responses_.find(response_id);
  if (it == pending_responses_.end())
    return;
  //取到指向被传入的ByteBuffer对象的地址指针 
  uint8_t* response_data =
      static_cast<uint8_t*>(env->GetDirectBufferAddress(java_response_data));
  //构建response
  std::vector<uint8_t> response = std::vector<uint8_t>(
      response_data, response_data + java_response_position);
  //从最开始的response中取到回调接口
  auto message_response = std::move(it->second);
  //移除这个response
  pending_responses_.erase(it);
  //调用Complete方法
  message_response->Complete(
      std::make_unique<fml::DataMapping>(std::move(response)));
}

{% endhighlight %}

这时候最开始在`pending_response`作用就体现出来啦，构建了回传数据response之后，最后调用了`message_response`的`Complete`将response返回。

接下来看看这个`Complete`方法吧。emmmm，首先我们得知道这个message_response是啥东西，它从it->second取得，我们返回上面看看最开始存的是个啥。

{% highlight java%}

  int response_id = 0;
  if (auto response = message->response()) {
    response_id = next_response_id_++;
    pending_responses_[response_id] = response;
  }

{% endhighlight %}

这个message是`PlatformMessage`对象，去看看

<br>

### platform_message.cc
------

{% highlight java%}

 public:
  const std::string& channel() const { return channel_; }
  const std::vector<uint8_t>& data() const { return data_; }
  bool hasData() { return hasData_; }

  //调用这个方法返回的是response_，这玩意儿在下面
  const fml::RefPtr<PlatformMessageResponse>& response() const {
    return response_;
  }
  
   private:
  PlatformMessage(std::string name,
                  std::vector<uint8_t> data,
                  fml::RefPtr<PlatformMessageResponse> response);
  PlatformMessage(std::string name,
                  fml::RefPtr<PlatformMessageResponse> response);
  ~PlatformMessage();

  std::string channel_;
  std::vector<uint8_t> data_;
  bool hasData_;
  //就是这个东西啦
  fml::RefPtr<PlatformMessageResponse> response_;
};

{% endhighlight %}

看到response()返回的是个`PlatformMessageResponse`对象，里面的`Complete`是个虚函数，然后找到了`PlatformMessageResponseAndroid`和`PlatformMessageResponseDart`实现类，这里应该看Dart，因为我们是在响应详细给Flutter嘛。

<br>

### platform_message_response_dart.cc
------

{% highlight java%}

void PlatformMessageResponseDart::Complete(std::unique_ptr<fml::Mapping> data) {
  if (callback_.is_empty())
    return;
  FML_DCHECK(!is_complete_);
  is_complete_ = true;
  //在ui_task_runner_新开一个task
  ui_task_runner_->PostTask(fml::MakeCopyable(
      [callback = std::move(callback_), data = std::move(data)]() mutable {
        std::shared_ptr<tonic::DartState> dart_state =
            callback.dart_state().lock();
        if (!dart_state)
          return;
        tonic::DartState::Scope scope(dart_state);
        // 将Java里面的数据打包成Dart可以识别的数据
        Dart_Handle byte_buffer = WrapByteData(std::move(data));
        // DartInvoke咯
        tonic::DartInvoke(callback.Release(), {byte_buffer});
      }));
}

{% endhighlight %}

这里的逻辑还是比较清楚的，ui_task_runner_新开一个task，在这个task里面把Java转换成dart的数据，然后调用Dart的回调方法，我们回到Dart层看一哈。

<br>

### ui.window.sendPlatformMessage
-----

{% highlight java%}

static Future<ByteData> _sendPlatformMessage(String channel, ByteData message) {
    final Completer<ByteData> completer = Completer<ByteData>();
    ui.window.sendPlatformMessage(channel, message, (ByteData reply) {
      try {
        completer.complete(reply);
      } catch (exception, stack) {
        FlutterError.reportError(FlutterErrorDetails(
          exception: exception,
          stack: stack,
          library: 'services library',
          context: 'during a platform message response callback',
        ));
      }
    });
    return completer.future;
  }

{% endhighlight %}

这个我们一开始的方法，在这里的completer.complete，最后我们得到了数据。


<br>


## 3.总结一下流程
-----

总体来看，方法调用的大概顺序应该是这样的：

![](https://i.loli.net/2019/03/16/5c8c97d972662.jpg)

从消息发送出去，到Native接收到消息返回数据，刚好是个闭环，契合了开头给出的官网的图（当然契合！）。

扒源码的过程中看C++内容还是很吃力，精进。

整个流程下来，中间有一些疑问和想法，再写另一篇记录一下吧。



> 参考资料：
> 
> 1.[](https://cloud.tencent.com/developer/article/1366113)
> 
> 2.[](https://www.yuque.com/xytech/flutter/fu7h25#kk7dnf)
> 
> 3.[](https://docs.flutter.io/index.html)
> 