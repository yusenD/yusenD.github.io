---
layout: post
title: Java知识清单
feature-img: "assets/img/background/pexels-photo20.jpeg"
thumbnail: "assets/img/background/pexels-photo18.jpeg"
tags: [面试]
---

>  但行好事，莫问前程。

<br>

* TOC
{:toc}

面试Java基础顶不住啊啊啊，亡羊补牢，亡羊补牢。


## Java 基础

### 1.Java有几种基本类型，都是多少字节

一共8种基本类型

* boolean：只有两个值true和false，JVM在编译的时候会将boolean类型的数据转为int，boolean数组会用byte数组表示。
* byte：8bit，1字节，有符号，-128 to 127 ($$ -2^7 $$ ~ $$ 2^7 -1$$)
* char：16bit，2字节，0 to 65535
* short：16bit，2字节，-32768 to 32767
* int：32bit，4字节
* long：64bit，8字节
* float：32bit，4字节
* double：64bit，8字节

对应的封装类型：
* Boolean
* Byte
* Character
* Short
* Integer
* Long
* Float
* Double

#### Q1.1 char可以表示中文吗？

答：可以，char 16bit 2字节，UTF-8是变长编码，3字节 英文1字节，gbk中文是2字节，英文1字节

#### Q1.2 向上转换类型

只能是小的变成大的，联系一下父类子类之间的转换。

### 2. == 和 equals()

这两个的主要区别有：
* == 如果用于比较对象的话，那么只有当两个对象的引用地址相同时，才返回true，所以==常用在比较基本数据类型。
* equals()方法用于检查对象的相等性，可以根据业务要求进行重写，如果不重新写的话，也是比较两个对象的内存地址是否相等。

举个例子🌰：
    
{% highlight java%}

String s1 = "abc"; //如果字符串池里面没有字符串"abc"，那么创建了一个对象。
String s2 = "abc";

System.out.println(s1 == s2);
System.out.println(s1.equals(s2));
    
s2 = new String("abc"); //如果字符串池里面没有字符串"abc"，那么这一行语句创建了两个对象。
System.out.println(s1 == s2);
System.out.println(s1.equals(s2));

{% endhighlight %}

上面的代码输出结果为：

```
true
true
false
true
```

在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。当使用 String a = "abc"这样的语句进行定义一个引用的时候，首先会在字符串缓冲池中查找是否已经相同的对象，如果存在，那么就直接将这个对象的引用返回给a，如果不存在，则需要新建一个值为"abc"的对象，再将新的引用返回a。String a = new String("abc");这样的语句明确告诉JVM想要产生一个新的String对象，并且值为"abc"，于是就在堆内存中的某一个小角落开辟了一个新的String对象。

这里还是要注意一点：String类里面的`equals()`方法已经被重写了，代码：
{% highlight java%}

public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }

{% endhighlight %}

另外，只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述。因此我们提倡大家用引号包含文本的方式来创建String对象以提高效率，实际上这也是我们在编程中常采用的。

### 3. 包装

拆箱和装箱，举个例子🌰：

> Integer i = 10; //装箱，自动将基本数据类型转换为wrapper
> int j = i; //拆箱，自动将wrapper转换为基本数据类型

原理：装箱的时候自动调用了Integer的`valueOf(int)`方法，而拆箱的时候调用了Integer的`intValue()`方法。

#### Q3.1 看输出结果

```
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;
         
        System.out.println(i1==i2);
        System.out.println(i3==i4);
    }
}
```

输出结果是：

```
true
false
```

之所以出现这样的结果，是因为在Java装箱的时候，`valueOf(int)`方法内有一个缓冲，当数值在[-128,127]范围之内，会直接返回缓冲。

{% highlight java%}

 public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)]; //-128 to 127
        return new Integer(i);
    }

{% endhighlight %}


类似的。

* Boolean全是返回预设值
* Character 0-127
* Byte -128 to 127
* Short -128 to 127
* Long -16-16

* Double 全都新创建
* Float 全都新创建

### 4.Object的方法

* clone：保护方法，实现对象的浅复制（就是重新克隆一个对象，但是对象里面的对象引用还是一样的），只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。在Java除了**8种基本类型传参数是值传递，其他的类对象传参数都是引用传递**，我们有时候不希望在方法里将参数改变，这是就需要在类中复写clone方法。
* getClass：final方法，获得运行时的类型。
* toString：用的挺多，经常覆盖。
* finalize：用于释放资源。
* equals：一般都要进行重写。
* hashCode：用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。

> 例如，假如写了一个类P，重写了P的equals的方法，如果参数值相等，那么这个返回true。
> 在用HashMap等集合时，P1和P2虽然值相等，但是仍然会被认为是两个对象，因为他们的hashCode不同。


* wait：wait方法使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait方法一直等待，直到获得锁或被中断。
* notify：唤醒在该对象上等待的某个进程。
* notifyAll：唤醒在该对象上等待的所有线程。

### Java的四个引用

* 强引用：最常见的引用
* 软引用：当内存不够的时候，会GC
* 弱引用：弱引用的生命周期更短，垃圾回收器在扫描的时候如果发现弱引用不管内存空间是否足够都会回收。经常与引用队列（ReferenceQueue联合使用），如果弱引用所引用的对象被垃圾回收，Java虚拟机会把这个弱引用加入到与之关联的引用队列中。
* 虚引用：不会决定对象的生命周期，主要用来跟踪对象被垃圾回收器回收的活动，必须和引用队列一起使用。

### Java是值传递

![](https://i.loli.net/2019/03/07/5c80e76bed667.jpg)

### Error和Exception的区别

Error和Exception的父类都是throwable类，在Java中，只有Throwable类型的实例才可以被抛出或者捕捉，是异常处理机制的基本组成类型。

* Exception：程序正常运行中，可以预料的意外情况，并且应该被捕捉，进行相应处理。
    * checked：可检查异常，在源代码里面必须显式地进行铺货，这是编译器检查的一部分。如，I/O操作时需要加try/catch
    * unchecked：运行时异常，比如**数组越界，空指针，访问受限**等，通常是可以避免的逻辑错误，不会在编译器强制要求。

* Error：运行程序中较为严重的问题，程序（JVM自身）进入非正常状态。如，OOM、StackOverflow、ClassDefNotFound

### final、finally、finalize区别

* final：修饰类、方法、变量，修饰类的话表示不可继承，修饰方法表示不可重写（Override），修饰变量表示不可更改。
* finally：保证重点代码一定会被执行的一种机制，可以unlock()，断开数据库连接等动作
* finalize：保证对象在垃圾收集前完成特定资源的回收。finalize机制已经不推荐使用

> 需要注意的是：final并不是等同于immutable
> 
> 在修饰对象的时候，final只能约束这个引用不可以被赋值，但是对象行为本身不受影响。如果要对象不可变，那么需要类支持，可以参照下面（比如`List.of()`方法。）
> * class自身声明final
> * 所有的成员变量定义为private和final，并且不要setter
> * 构造对象用深拷贝来初始化，而不是直接赋值
> * 如果要使用getter方法，可以使用copy-on-write原则
> 

### String/StringBuilder/StringBuffer

* String：不可变，无法继承（注意：JDK9 中，String底层，char数组变成了byte数组）
* StringBuilder：线程不安全，大部分情况下字符串拼接的首选
* StringBuffer：线程安全


1.线程

String是Immutable，线程安全，而StringBuffer是通过把各种修改数据的方法加上了synchronized。目前，SB内部数组初始长度为16。

2.字符串缓存

避免重复创建字符串可以很好的降低内存开销，可以考虑使用`intern()`方法。在JDK6，缓存的字符是在永久代里面的，如果使用不当，就会OOM。

后续版本中，缓存在堆里，甚至在JDK8版本，永久代被MetaSpace代替了。

3.String的演化

JDK9引入了Compact Strings设计，数据存储方式由char变成了byte加coder（编码标识）。

### 反射机制/动态代理

* 反射是Java的一种基础功能，赋予程序在运行时自省（introspect）的能力，通过反射可以操作类或对象，比如获取某个对象的类定义、获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类的定义。

* 动态代理是一种方便运行时构建代理，动态处理代理方法调用的机制，比如面向切面编程(AOP)。


* Class类：代表一个类，位于java.lang包下
* Field类：代表类的成员变量（成员变量也称为类的属性）
* Method类：代表类的方法
* Constructor类：代表类的构造方法
* Array类：提供了动态创建数组，以及访问数组的元素的静态方法

获取Class对象方式：
{% highlight java%}

    //方式一
    Person person = new Person();
    Class<? extends Person> personClazz01 = person.getClass();

    //方式二
    try {
        Class<?> personClazz02 = Class.forName("Person");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }

    //方式三
    Class<? extends Person> personClazz03 = Person.class;

{% endhighlight %}

### 注解












## Java 面向对象

## Java 容器相关

## Java I/O

## Java 多线程并发

太重要了，面试基本都问到了线程问题，这里得好好地看一下。

### 1.多线程创建 

#### Thread/Runnable

* 继承Thread类
* 实现Runnable接口

{% highlight java%}

ThreadRunnableDemo d = new ThreadRunnableDemo();
Thread t1 = new Thread(d);
t1.start();

CloneTest t2 = new CloneTest();
t2.start();

{% endhighlight %}


#### 两种启动线程方法的区别

两种方法都要用Thread产生线程，调用start方法开启线程。

实现Runnable比继承Thread要更灵活。


#### start和run方法的区别

start方法是开启线程的方法，实现了多线程的运行。

run方法包含了线程要执行的内容，如果调用run方法的话，还是按顺序执行，没有多线程的效果。

### 2.线程间通信

#### synchronized关键字（重要）

1）synchronize对象锁

{% highlight java%}

synchronized public void methodA() {
    //Do something
}

public void methodB() {
    synchronized (this){
         //Do something   
    }
}

{% endhighlight %}


2) synchronize实现线程通信

通过共享同一变量，来实现锁的管理。

{% highlight java%}

class MyObject{
    synchronized public void methodA() {
        System.out.println(666);
    }

    synchronized public void methodB() {
        System.out.println(777);
    }
}

class ThreadA extends Thread{
    MyObject object;
    public ThreadA(MyObject object){
        this.object = object;
    }


    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}

class ThreadB extends Thread{
    MyObject object;
    public ThreadB(MyObject object){
        this.object = object;
    }


    @Override
    public void run() {
        super.run();
        object.methodB();
    }
}

public class Main {


    public static void main(String[] args) {

        MyObject object = new MyObject();
        //线程持有一个对象
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();

    }
}

{% endhighlight %}

3) synchronize/volatile

volatile不允许线程有自己的一份拷贝，都从主内存去拷贝：被修饰的变量，修改之后，所有线程这个值都会改。会对性能有所消耗。只能在线程内存和主内存之间同步一个值。

synchronize关键字获取释放锁都有监听器（monitor），锁住了一个对象之后，其他线程无法进入。执行完了之后，释放锁给监听器。可以同步所有变量的值，性能消耗更多。

本质上，volatile相当于告诉JVM，这个值是不安全的，如果你要获取，从主内存去获取，只能修饰变量。而synchronize是锁住，修饰类、变量、方法。

4）synchronized/lock

lock方法需要制定起始和终止位置，有lock()和unlock()，防止死锁还要在在finally进行unlock()。性能上，synchronized是托管给JVM的，而lock是需要自己实现的，所以lock的性能会更高一些。

synchronized是悲观锁，独占锁，别的线程只能用阻塞来等待释放锁；而lock是乐观锁，假设没有冲突，去完成某个操作，如果有冲突失败就重试，直到成功为止。



#### sleep/wait

锁。sleep，在一段时间内阻塞线程执行，不会改变线程持有锁，而wait是用锁来控制的


#### wait/notify机制

锁。wait需要在同步代码块调用，调用之后等待锁，通知notify释放锁。

### 3.线程池

#### 好处

降低资源消耗、提高响应速度、提高线程的可管理性。

#### ThreadPollExecutor

new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);

* corePoolSize：线程池基本大小
* maximumPoolSize：最大容量，限制队列数
* keepAliveTime：工作空闲存活时间
* milliseconds：
* runnableTaskQueue：
* handler：队列线程池满了，需要有一个策略进行处理

创建线程池==》提交任务executor

#### 线程池工作流程


当我们提交一个新的任务：

* 判断线程池是否已满，如果满了下一流程，如果没满，创建工作线程执行该任务
* 其次线程池判断工作队列是否已满，如果满了进入下一流程，否则提交任务到该队列中进行处理
* 判断整个线程池是否已满，都满了就交给饱和策略，丢弃or Something else

### 2.线程间通信

### 3.线程池

## Java 反射

## Java 泛型

## JVM 相关

### 1.JVM内存分配

* 程序计数器：是线程私有的，每一条线程都有一个独立的程序计数器。执行Java方法时候，记录的是正在执行的虚拟机字节码指令的地址，当执行的是Native方法，值为空。是唯一一个没有规定任何OOM的区域。
* 虚拟机栈：线程私有，生命周期和线程相同。描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中.
* 本地方法栈：该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。
* Java堆：是最大的一块，所有的线程共享。几乎所有的对象示例(用new产生的数据)和数组都这里分配内存。垃圾收集器管理的主要区域，所以也叫GC堆。 逻辑上连续。
* 方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。包含常量池：存放常量，在程序执行的时候，常量池会存储在方法区！而不是堆中！！


> 参考资料：
> https://www.cnblogs.com/dolphin0520/p/3780005.html
> https://lz12366.iteye.com/blog/644141
