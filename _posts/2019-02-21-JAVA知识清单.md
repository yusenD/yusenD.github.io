---
layout: post
title: Java知识清单
feature-img: "assets/img/background/pexels-photo20.jpeg"
thumbnail: "assets/img/background/pexels-photo18.jpeg"
tags: [面试]
---

>  但行好事，莫问前程。

<br>

* TOC
{:toc}

面试Java基础顶不住啊啊啊，亡羊补牢，亡羊补牢。


## Java 基础

### 1.Java有几种基本类型，都是多少字节

一共8种基本类型

* boolean：只有两个值true和false，JVM在编译的时候会将boolean类型的数据转为int，boolean数组会用byte数组表示。
* byte：8bit，1字节，有符号，-128 to 127 ($$ -2^7 $$ ~ $$ 2^7 -1$$)
* char：16bit，2字节，0 to 65535
* short：16bit，2字节，-32768 to 32767
* int：32bit，4字节
* long：64bit，8字节
* float：32bit，4字节
* double：64bit，8字节

对应的封装类型：
* Boolean
* Byte
* Character
* Short
* Integer
* Long
* Float
* Double

#### Q1.1 char可以表示中文吗？

答：可以，char 16bit 2字节，UTF-8是变长编码，3字节 英文1字节，gbk中文是2字节，英文1字节

#### Q1.2 向上转换类型

### 2. == 和 equals()

这两个的主要区别有：
* == 如果用于比较对象的话，那么只有当两个对象的引用地址相同时，才返回true，所以==常用在比较基本数据类型。
* equals()方法用于检查对象的相等性，可以根据业务要求进行重写，如果不重新写的话，也是比较两个对象的内存地址是否相等。

举个例子🌰：
    
{% highlight java%}

String s1 = "abc"; //如果字符串池里面没有字符串"abc"，那么创建了一个对象。
String s2 = "abc";

System.out.println(s1 == s2);
System.out.println(s1.equals(s2));
    
s2 = new String("abc"); //如果字符串池里面没有字符串"abc"，那么这一行语句创建了两个对象。
System.out.println(s1 == s2);
System.out.println(s1.equals(s2));

{% endhighlight %}

上面的代码输出结果为：

```
true
true
false
true
```

在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。当使用 String a = "abc"这样的语句进行定义一个引用的时候，首先会在字符串缓冲池中查找是否已经相同的对象，如果存在，那么就直接将这个对象的引用返回给a，如果不存在，则需要新建一个值为"abc"的对象，再将新的引用返回a。String a = new String("abc");这样的语句明确告诉JVM想要产生一个新的String对象，并且值为"abc"，于是就在堆内存中的某一个小角落开辟了一个新的String对象。

这里还是要注意一点：String类里面的`equals()`方法已经被重写了，代码：
{% highlight java%}

public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }

{% endhighlight %}

另外，只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述。因此我们提倡大家用引号包含文本的方式来创建String对象以提高效率，实际上这也是我们在编程中常采用的。

### 3. 包装

拆箱和装箱，举个例子🌰：

> Integer i = 10; //装箱，自动将基本数据类型转换为wrapper
> int j = i; //拆箱，自动将wrapper转换为基本数据类型

原理：装箱的时候自动调用了Integer的`valueOf(int)`方法，而拆箱的时候调用了Integer的`intValue()`方法。

#### Q3.1 看输出结果

```
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;
         
        System.out.println(i1==i2);
        System.out.println(i3==i4);
    }
}
```

输出结果是：

```
true
false
```

之所以出现这样的结果，是因为在Java装箱的时候，`valueOf(int)`方法内有一个缓冲，当数值在[-128,127]范围之内，会直接返回缓冲。

{% highlight java%}

 public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)]; //-128 to 127
        return new Integer(i);
    }

{% endhighlight %}


类似的。

* Boolean全是返回预设值
* Character 0-127
* Byte -128 to 127
* Short -128 to 127
* Long -16-16

* Double 全都新创建
* Float 全都新创建

### 4.Object的方法

* clone：保护方法，实现对象的浅复制（就是重新克隆一个对象，但是对象里面的对象引用还是一样的），只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。在Java除了**8种基本类型传参数是值传递，其他的类对象传参数都是引用传递**，我们有时候不希望在方法里将参数改变，这是就需要在类中复写clone方法。
* getClass：final方法，获得运行时的类型。
* toString：用的挺多，经常覆盖。
* finalize：用于释放资源。
* equals：一般都要进行重写。
* hashCode：用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。

> 例如，假如写了一个类P，重写了P的equals的方法，如果参数值相等，那么这个返回true。
> 在用HashMap等集合时，P1和P2虽然值相等，但是仍然会被认为是两个对象，因为他们的hashCode不同。


* wait：wait方法使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait方法一直等待，直到获得锁或被中断。
* notify：唤醒在该对象上等待的某个进程。
* notifyAll：唤醒在该对象上等待的所有线程。

## Java 面向对象

## Java 容器相关

## Java I/O

## Java 多线程并发

太重要了，面试基本都问到了线程问题，这里得好好地看一下。

### 1.多线程创建 

#### Thread/Runnable

* 集成Thread类
* 实现Runnable接口

{% highlight java%}

ThreadRunnableDemo d = new ThreadRunnableDemo();
Thread t1 = new Thread(d);
t1.start();

CloneTest t2 = new CloneTest();
t2.start();

{% endhighlight %}


#### 两种启动线程方法的区别

两种方法都要用Thread产生线程，调用start方法开启线程。

实现Runnable比继承Thread要更灵活。


#### start和run方法的区别

start方法是开启线程的方法，实现了多线程的运行。

run方法包含了线程要执行的内容，如果调用run方法的话，还是按顺序执行，没有多线程的效果。

### 2.线程间通信

#### synchronized关键字（重要）

1）synchronize对象锁

{% highlight java%}

synchronized public void methodA() {
    //Do something
}

public void methodB() {
    synchronized (this){
         //Do something   
    }
}

{% endhighlight %}


2) synchronize实现线程通信

通过共享同一变量，来实现锁的管理。

{% highlight java%}

class MyObject{
    synchronized public void methodA() {
        System.out.println(666);
    }

    synchronized public void methodB() {
        System.out.println(777);
    }
}

class ThreadA extends Thread{
    MyObject object;
    public ThreadA(MyObject object){
        this.object = object;
    }


    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}

class ThreadB extends Thread{
    MyObject object;
    public ThreadB(MyObject object){
        this.object = object;
    }


    @Override
    public void run() {
        super.run();
        object.methodB();
    }
}

public class Main {


    public static void main(String[] args) {

        MyObject object = new MyObject();
        //线程持有一个对象
        ThreadA a = new ThreadA(object);
        ThreadB b = new ThreadB(object);
        a.start();
        b.start();

    }
}

{% endhighlight %}

3) synchronize/volatile

volatile不允许线程有自己的一份拷贝，都从主内存去拷贝：被修饰的变量，修改之后，所有线程这个值都会改。会对性能有所消耗。只能在线程内存和主内存之间同步一个值。

synchronize关键字获取释放锁都有监听器（monitor），锁住了一个对象之后，其他线程无法进入。执行完了之后，释放锁给监听器。可以同步所有变量的值，性能消耗更多。

本质上，volatile相当于告诉JVM，这个值是不安全的，如果你要获取，从主内存去获取，只能修饰变量。而synchronize是锁住，修饰类、变量、方法。

4）synchronized/lock

lock方法需要制定起始和终止位置，有lock()和unlock()，防止死锁还要在在finally进行unlock()。性能上，synchronized是托管给JVM的，而lock是需要自己实现的，所以lock的性能会更高一些。

synchronized是悲观锁，独占锁，别的线程只能用阻塞来等待释放锁；而lock是乐观锁，假设没有冲突，去完成某个操作，如果有冲突失败就重试，直到成功为止。



#### sleep/wait

锁。sleep，在一段时间内阻塞线程执行，不会改变线程持有锁，而wait是用锁来控制的


#### wait/notify机制

锁。wait需要在同步代码块调用，调用之后等待锁，通知notify释放锁。

### 3.线程池

#### 好处

降低资源消耗、提高响应速度、提高线程的可管理性。

#### ThreadPollExecutor

new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);

* corePoolSize：线程池基本大小
* maximumPoolSize：最大容量，限制队列数
* keepAliveTime：工作空闲存活时间
* milliseconds：
* runnableTaskQueue：
* handler：队列线程池满了，需要有一个策略进行处理

创建线程池==》提交任务executor

#### 线程池工作流程


当我们提交一个新的任务：

* 判断线程池是否已满，如果满了下一流程，如果没满，创建工作线程执行该任务
* 其次线程池判断工作队列是否已满，如果满了进入下一流程，否则提交任务到该队列中进行处理
* 判断整个线程池是否已满，都满了就交给饱和策略，丢弃or Something else

### 2.线程间通信

### 3.线程池

## Java 反射

## Java 泛型

## JVM 相关

### 1.JVM内存分配

* 程序计数器：是线程私有的，每一条线程都有一个独立的程序计数器。执行Java方法时候，记录的是正在执行的虚拟机字节码指令的地址，当执行的是Native方法，值为空。是唯一一个没有规定任何OOM的区域。
* 虚拟机栈：线程私有，生命周期和线程相同。描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中.
* 本地方法栈：该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。
* Java堆：是最大的一块，所有的线程共享。几乎所有的对象示例(用new产生的数据)和数组都这里分配内存。垃圾收集器管理的主要区域，所以也叫GC堆。 逻辑上连续。
* 方法区：方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”。包含常量池：存放常量，在程序执行的时候，常量池会存储在方法区！而不是堆中！！


> 参考资料：
> https://www.cnblogs.com/dolphin0520/p/3780005.html
> https://lz12366.iteye.com/blog/644141
