---
layout: post
title: 剑指Offer——LeetCode
feature-img: "assets/img/background/pexels-photo5.jpeg"
tags: [算法,面试]
---

> 我想要靠傍近你，方不至于难过。 <br>                     
> <p align="right">——沈从文《湘行书简》</p>


## 8.String to Integer (atoi)
----

思路：比较简单。记录注意一下Integer和String的几个方法使用即可。

str.toCharArray ：String转char数组，运行起来会更快，就不用charAt了。

{% highlight java%}

 int result = 0;
        int i = 0;
        int flag = 1;
        
        if(str.length()==0){
            return 0;
        }
        
        
        while(i<str.length() && str.charAt(i) == ' '){
            i++;
        }
        if(i<str.length() && str.charAt(i) == '+'){
            flag = 1;
            i++;
        }else if(i<str.length() && str.charAt(i) == '-'){
            flag = -1;
            i++;
        }
        
        int digit = 0;
        
        while( i<str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9'){
            digit = str.charAt(i) - '0';
            if(result > (Integer.MAX_VALUE-digit)/10) {
                return flag==1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            
            result *= 10;
            result += digit;
            i++;
        }
        result *= flag;
        return (int)result;

{% endhighlight %}

## 10.Regular Expression Matching

思路：动态规划问题，需要找到后面的问题对于前面问题的依赖。

对于这种匹配来说，需要考虑的情况主要有：
* 1.字符相等：m[i][j] = m[i-1][j-1]，即结果与前面字符匹配情况保持一致
* 2.字符不等，但是模式串的字符是‘*’：与模式串的前一个字符进行比较

{% highlight java%}

public static boolean isMatch(String s, String p) {

        if(p==null || p.length() == 0) return (s == null || s.length() == 0);

        int sl = s.length();
        int pl = p.length();

        boolean[][] m = new boolean[sl + 1][pl + 1];

        m[0][0] = true;

        for(int i=2;i<=pl;i++){
            m[0][i] = p.charAt(i-1) == '*' && m[0][i-2];
        }

        for(int i = 1;i<=sl;i++){
            for(int j = 1;j<=pl;j++){
                if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.') m[i][j] = m[i-1][j-1];
                else{
                    if(p.charAt(j-1) == '*'){
                        m[i][j] = m[i][j-2] || ((s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.') && m[i-1][j]);
                    }
                }
            }
        }

        return m[sl][pl];

    }

{% endhighlight %}


# 11.Container With Most Water

最简单的方法就是暴力结局，时间复杂度$O(n ^2)$，存在更简单的解法。

从两边开始，计算出一个面积，找到两边中最短的边，此时对于这条短边来说，包含它所能形成最大的面积，就是这个面积了，所以我们不需要再考虑这条边，进行下条边的计算。

{% highlight java%}

public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int maxArea = 0;
        while(l<r){
            maxArea = Math.max(maxArea,Math.min(height[l],height[r]) * (r-l));
            if(height[l] < height[r]) l++;
            else r--;
        }
        return maxArea;
    }

{% endhighlight %}

## 12.3Sum

思路：
* 首先：暴力解法不可取。
* 和之前的那个两个数字相加的算法差不多，可以把第一个数字提出来，然后设定一下target值，从后面的数字里面找两个数字相加等于这个target值。直接套用2Sum的话，时间差点就LTE了，不可取。
* 所以需要优化一下。


用时1000ms+的垃圾算法，直接套用了2Sum的算法。

{% highlight java%}

public List<List<Integer>> threeSum(int[] nums) {
        int len = nums.length;
        
        Arrays.sort(nums);
        
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        
        if(len<3 || nums[0] > 0 || nums[len-1]<0) return result;
        
        Map<Integer,Integer> map = new HashMap<>();
        for(int j = 0 ; j < len; j++) map.put(nums[j],j);
        
        for(int i = 0 ;i<len-2 && nums[i] <= 0 ; i++){
            
            if(nums[i] != 0) map.remove(nums[i]);
            
            if(i>0 && nums[i] == nums[i-1]) continue;
            
            int target = 0 - nums[i];            
            
            for(int j = i+1 ; j < len; j++){
                if(map.containsKey(target-nums[j]) && map.get(target-nums[j]) > j){
                    List<Integer> temp = new ArrayList<Integer>();
                    temp.add(nums[i]);
                    temp.add(nums[j]);
                    temp.add(nums[map.get(target-nums[j])]);
                    if(!result.contains(temp)) result.add(temp);
                }
            }
             
        }
        
        return result;
    }

{% endhighlight %}


优化思路：数组排序过之后，可以通过两个指针进行一次遍历。low和high相加如果比target大的话，说明加的多了，high前移小一点；设置target值的时候，过滤相同值；计算完了一轮之后，注意low和high去重

{% highlight java%}

public static List<List<Integer>> threeSumSimple(int[] nums) {

        int len = nums.length;

        if (len < 3) return new ArrayList<>();
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        int target;

        for (int i = 0; i < len - 2 && nums[i] <= 0; i++) {

            if (i > 0 && nums[i] == nums[i - 1]) continue;
            target = -nums[i];
            int high = len - 1;
            int low = i + 1;
            while (low < high) {
                int sum = nums[low] + nums[high];
                if (sum > target) high--;
                else if (sum < target) low++;
                else {
                    result.add(Arrays.asList(nums[i],nums[low],nums[high]));
                    while(low<high && nums[low] == nums[low+1]) low++;
                    while(low<high && nums[high] == nums[high-1]) high--;
                    low++;
                    high--;
                }
            }
        }

        return result;

    }

{% endhighlight %}




