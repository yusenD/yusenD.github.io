---
layout: post
title: 算法————队列
feature-img: "assets/img/background/pexels-photo10.jpeg"
tags: [面试,算法]
---

> 我去，你留<br>
> 两个秋                        
> <p align="right">——正冈子规</p>

* TOC
{: toc}



### 队列的结构
----

队列是一种**先进先出**的数据结构，和栈类似，也是一种操作受限的线性表数据结构。

栈只有两个操作：入队（enqueue）和出队（dequeue）。从队尾插入元素，从头部取出元素。

### 实现
----

用数组实现的队列叫做顺序队列，用链表实现的叫做链式队列。

分别实现一下：

顺序队列：

{% highlight java%}



{% endhighlight %}

链式队列：

{% highlight java%}



{% endhighlight %}

还有一种十分重要的队列，**循环队列**。这个队列画出来吧，就是这样的：

![](media/15391804731238.jpg)

这样的循环队列的实现要困难一些，不过更好确定队列空和队列满的情况。队列空就是`tail = head`，队列满就是tail在head的前一个位置，`(tail+1)%n = head`。

需要注意的是，tail指向的位置实际上并没有存数据。

代码实现：

{% highlight java%}

{% endhighlight %}

### 阻塞队列和并发队列
----

其实，队列这种数据结构很基础，平时的业务开发不太可能需要从零实现一个队列，甚至都不会直接用到。但是一些特殊的队列应用很广，比如阻塞队列和并发队列。

**阻塞队列**其实就是在队列的基础上增加了阻塞操作，简单来说，就是在队列为空的时候，从队尾取数据会被阻塞，因为此时没有数据可以取，当有了数据之后才能返回；如果队列满了，那么插入数据操作就会被阻塞，当队列中有空闲位置之后再插入，然后再返回。这其实就是“生产者-消费者模型”。

线程安全的队列被称为**并发队列**。最简单的实现方式是直接在enqueue和dequeue方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，给予数组的循环队列，利用CSA原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

### 一个问题

CPU的资源是有限的，任务的处理速度与线程个数并不是线性正相关的。相反，过多的线程反而会导致CPU频繁切换，使得处理性能下降。所以线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。

当我们向固定大小的线程池中请求一个线程的时候，如果线程池中没有空闲资源了，这时候线程如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？

我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程的时候，去处排队的请求继续处理。

我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？

基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。

而基于数组实现的有界队列，队列的大小是有限的，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝。这种方式对于响应时间比较敏感的系统来说，就相对更合适了。不过设置一个合理的队列大小是十分重要的，队列太小使得没办法充分利用系统资源。

队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

### 实现无锁并发队列




