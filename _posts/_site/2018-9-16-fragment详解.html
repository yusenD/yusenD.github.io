<p>Fragment是开发中非常常用的控件，最近开发用了不少Fragment，搜集资料花了不少功夫，稍微总结一下</p>

<ul id="markdown-toc">
  <li><a href="#概述" id="markdown-toc-概述">概述</a></li>
  <li><a href="#生命周期" id="markdown-toc-生命周期">生命周期</a></li>
  <li><a href="#使用" id="markdown-toc-使用">使用</a>    <ul>
      <li><a href="#1基本用法" id="markdown-toc-1基本用法">1.基本用法</a></li>
      <li><a href="#2fragment添加activity" id="markdown-toc-2fragment添加activity">2.Fragment添加Activity</a></li>
      <li><a href="#3常见异常" id="markdown-toc-3常见异常">3.常见异常</a></li>
    </ul>
  </li>
</ul>
<p><br /></p>
<h2 id="概述">概述</h2>
<hr />
<p>Fragment是在<code class="highlighter-rouge">API 11</code>（Android 3.0）加入的，后来为了兼容更低版本，开发了support-v4库的fragment。<br />
目前Fragment有<code class="highlighter-rouge">android.app.fragment</code>和<code class="highlighter-rouge">android.support.v4.app.Fragment</code>，在当前<code class="highlighter-rouge">API 28</code>（Android 9.0）中，前者已经不推荐使用了。<br />
所以更推荐使用后者。</p>

<p><img src="https://i.loli.net/2018/09/16/5b9e4aaac4d0e.jpg" alt="" /></p>

<p><br />
<strong>Fragment官方的定义是：</strong></p>

<blockquote>
  <p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p>
</blockquote>

<p><br />
根据上面的定义可知：</p>
<ul>
  <li>
    <p>Fragment是依赖于Activity的，不能独立存在的。</p>
  </li>
  <li>
    <p>一个Activity里可以有多个Fragment。</p>
  </li>
  <li>
    <p>一个Fragment可以被多个Activity重用。</p>
  </li>
  <li>
    <p>Fragment有自己的生命周期，并能接收输入事件。</p>
  </li>
  <li>
    <p>我们能在Activity运行时动态地添加或删除Fragment。
<br /></p>
  </li>
</ul>

<p><strong>Fragment的主要方法</strong></p>
<ul>
  <li>Fragment：Fragment的基类，任何创建fragment都需要继承自该类。</li>
  <li>FragmentManager：主要是负责管理和维护Fragment。是抽象类，具体实现类是FragmentManagerImpl。</li>
  <li>FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。是抽象类，具体的实现类BackStackRecord。</li>
  <li>NestedFragment：在Fragment的内部嵌套Fragment
<br /><br /></li>
</ul>

<h2 id="生命周期">生命周期</h2>
<hr />
<p>需要注意的是Fragment不是一个View，而是和Activity同一层次的。</p>

<p>Fragment的生命周期与Activity类似，但是更为复杂。</p>

<p><img src="https://i.loli.net/2018/09/16/5b9e5e1940a2f.jpg" alt="" /></p>

<p>每一步解释如下：</p>

<table>
  <tbody>
    <tr>
      <td>onAttach()</td>
      <td>Fragment和Activity相关联的时候进行调用，通过该方法可以获取Activity引用，还可以用<code class="highlighter-rouge">getArguments</code>来获取参数</td>
    </tr>
    <tr>
      <td>onCreate()</td>
      <td>Fragment被创建之后进行调用</td>
    </tr>
    <tr>
      <td>onCreateView()</td>
      <td>创建Fragment的布局</td>
    </tr>
    <tr>
      <td>onActivityCreate()</td>
      <td>当Activity完成onCreate()时调用</td>
    </tr>
    <tr>
      <td>onStart()</td>
      <td>Fragment可见是进行调用</td>
    </tr>
    <tr>
      <td>onResume()</td>
      <td>Fragment可见并且可以交互是进行调用</td>
    </tr>
    <tr>
      <td>onPause()</td>
      <td>Fragment不可交互但可见调用</td>
    </tr>
    <tr>
      <td>onStop()</td>
      <td>Fragment不可见是调用</td>
    </tr>
    <tr>
      <td>onDestoryView()</td>
      <td>Fragment的UI从视图结构中移除时调用</td>
    </tr>
    <tr>
      <td>onDestory()</td>
      <td>销毁Fragment时调用</td>
    </tr>
    <tr>
      <td>onDetach()</td>
      <td>Fragment和Activity解除关联时调用</td>
    </tr>
  </tbody>
</table>

<p>以上方法，出了onCreateView在重写的时候不用写super方法，其余的都需要。</p>

<p><br /><br /></p>

<h2 id="使用">使用</h2>
<hr />
<h3 id="1基本用法">1.基本用法</h3>
<p><br /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fragment1</span> <span class="kd">extends</span> <span class="n">Fragment</span><span class="o">{</span>  
    
    <span class="kd">public</span> <span class="n">View</span> <span class="nf">onCreateView</span><span class="o">(</span><span class="n">LayoutInflater</span> <span class="n">inflater</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">container</span><span class="o">,</span> <span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">View</span> <span class="n">view</span> <span class="o">=</span> <span class="n">inflater</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">hello_fragment</span><span class="o">,</span> <span class="n">container</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">view</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Fragment1</span> <span class="nf">newInstance</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Fragment1</span> <span class="n">frag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fragment1</span><span class="o">();</span>
        <span class="n">Bundle</span> <span class="n">bundle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bundle</span><span class="o">();</span>
        <span class="n">bundle</span><span class="o">.</span><span class="na">putString</span><span class="o">(</span><span class="n">ARG_PARAM</span><span class="o">,</span> <span class="n">str</span><span class="o">);</span>
        <span class="n">fragment</span><span class="o">.</span><span class="na">setArguments</span><span class="o">(</span><span class="n">bundle</span><span class="o">);</span>   <span class="c1">//设置参数</span>
        <span class="k">return</span> <span class="n">fragment</span><span class="o">;</span>
    <span class="o">}</span>    
    
<span class="o">}</span></code></pre></figure>

<p><br />
重写onCreateView方法，绑定layout，页面就有了。</p>

<p>如果要传递参数的话，可以通过<code class="highlighter-rouge">setArguments</code>方法传入<code class="highlighter-rouge">Bundle</code>，不推荐用构造方法的方法，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。</p>

<p>官方建议：</p>
<blockquote>
  <p>It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated.</p>
</blockquote>

<p>如果要获取到这些参数，可以用Fragment的<code class="highlighter-rouge">onAttach</code>方法通过<code class="highlighter-rouge">getArguments</code>方法获得，并且在获取之后使用这些参数。</p>

<p>如果要获取的Activity对象，不建议用<code class="highlighter-rouge">getActivity</code>方法，而是在<code class="highlighter-rouge">onAttach</code>方法中将Context对象强转成Activity对象。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Activity</span> <span class="n">mActivity</span><span class="o">;</span>
<span class="kd">private</span> <span class="n">String</span> <span class="n">param</span><span class="o">;</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAttach</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">mActivity</span> <span class="o">=</span> <span class="o">(</span><span class="n">Activity</span><span class="o">)</span><span class="n">context</span><span class="o">;</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">getArguments</span><span class="o">().</span><span class="na">getString</span><span class="o">(</span><span class="n">KEY_PARAM</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p><br /></p>
<h3 id="2fragment添加activity">2.Fragment添加Activity</h3>
<p><br />
主要有两种方法：</p>
<ul>
  <li>静态添加：  直接在xml文件中进行绑定，非常不灵活，很少用到</li>
  <li>动态添加：  在代码中添加，比较灵活，建议使用</li>
</ul>

<p>在Activity的XML文件加入一个布局容器，最简单的FrameLayout即可，然后通过下面代码加入到Activity中：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getSupportFragmentManager().beginTransaction()
    .add(R.id.fl_container, HelloFragment.newInstance("hello world"), "f1")
    .commit();
</code></pre></div></div>

<p><strong>需要注意的是：</strong></p>

<ul>
  <li>因为使用的是support-v4库的Fragment，所以需要使用<code class="highlighter-rouge">getSupportFragmentManager</code>方法来获取FragmentManager。</li>
  <li><code class="highlighter-rouge">add()</code>方法中有三个参数，第一个是容器，第二个是Fragment对象，第三个是Fragment的「 tag 」名，作用是以后可以用<code class="highlighter-rouge">findFragmentByTag(tag)</code>方法，根据tag从FragmentManager中找到Fragment对象。</li>
  <li>在一次事务中，可以进行多个操作，比如<code class="highlighter-rouge">add().remove().replace()</code></li>
  <li><code class="highlighter-rouge">commit()</code>操作是异步的，内部通过<code class="highlighter-rouge">enqueueAction()</code>加入处理队列。对应的同步方法为<code class="highlighter-rouge">commitNow()</code>，<code class="highlighter-rouge">commit()</code>内部会有<code class="highlighter-rouge">checkStateLoss()</code>操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而<code class="highlighter-rouge">commitAllowingStateLoss()</code>方法则是不会抛出异常版本的<code class="highlighter-rouge">commit()</code>方法，但是尽量使用<code class="highlighter-rouge">commit()</code>，而不要使用<code class="highlighter-rouge">commitAllowingStateLoss()</code>。</li>
  <li><code class="highlighter-rouge">addToBackStack("fname")</code>是可选的。FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</li>
  <li>Fragment有一个常见的问题，即Fragment重叠问题，这是由于Fragment被系统杀掉，并重新初始化时再次将fragment加入activity，因此通过在外围加if语句能判断此时是否是被系统杀掉并重新初始化的情况。</li>
</ul>

<p><br /></p>
<h3 id="3常见异常">3.常见异常</h3>
<p><br /></p>

<p>如下：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)
    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)
    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)
    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)
</code></pre></div></div>

<p>该异常出现的原因是：<code class="highlighter-rouge">commit()</code>在<code class="highlighter-rouge">onSaveInstanceState()</code>后调用。首先，<code class="highlighter-rouge">onSaveInstanceState()</code>在<code class="highlighter-rouge">onPause()</code>之后，<code class="highlighter-rouge">onStop()</code>之前调用。<code class="highlighter-rouge">onRestoreInstanceState()</code>在<code class="highlighter-rouge">onStart()</code>之后，<code class="highlighter-rouge">onResume()</code>之前。</p>

<p>因此避免出现该异常的方案有：</p>

<ul>
  <li>
    <p>不要把Fragment事务放在异步线程的回调中，比如不要把Fragment事务放在AsyncTask的onPostExecute()，因此onPostExecute()可能会在onSaveInstanceState()之后执行。</p>
  </li>
  <li>
    <p>逼不得已时使用commitAllowingStateLoss()。</p>
  </li>
</ul>

<p><br />
<br /></p>
<blockquote>
  <p>参考公众号：腾讯Bugly</p>
</blockquote>

