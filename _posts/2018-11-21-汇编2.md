---
layout: post
title: 汇编（二）
feature-img: "assets/img/background/pexels-photo9.jpeg"
tags: [汇编]
---

> 绝望的时候依然要临水照镜 <br>     
> <p align="right">——《私房书》</p> 

<br>

## 算数运算类指令

### 1.加法指令

* 普通加法指令 ADD
* 带进位的加法指令ADC 
* 加1指令INC 不会影响CF，之后影响后五位标志位 

#### ADD
例子：
> MOV AL, 78H
> ADD AL, 99H

> 标志位：
> 
> | CF | 进位标志 | SF | 符号标志 |
| AF | 辅助进位标志 | ZF | 结果为0标志 |
| PF | 奇偶标志 | OF | 溢出标志 |

例如：01111000 + 10011001 = [1] 00010001

标志位状态：

| CF | 有一个1的进位，所以为1 | SF | 最高位数字为0，所以为0 |
| AF | 半加进位，第四位加第五位有进位，所以为1 | ZF | 结果不为0，所以为0 |
| PF | 1的个数为偶数个（不包括进位的那个1），所以为1 | OF | 次高位和最高位进位相同，所以为0 |

----

#### ADC

使用的要求与ADD一样
ADC OPRD1 OPRD2
OPRD1 + OPRD2 + CF -> OPRD1

多用于多字节数相加，使用之前一定要先把CF清零

----

#### INC

INC OPRD ;不能是段寄存器和立即数

> OPRD + 1 -> OPRD

就是加一，但是操作数不能使段寄存器和立即数

INC指令的执行不影响CF，但会影响其余5位标志位，经常用来修改指针


----

#### 例子🌰：

* 求内存数据段中M1位首和M2位首的两个20字节数之和，并将结果写入M2位首的区域中。

{% highlight java%}
    LEA SI, M1
    LEA DI, M2
    MOV CX, 20 ;20这个数很小，也可以送到CL或者是CL里面，但是循环控制指令必须要CX
    CLC ;CF清零命令，即lear cf
NEXT: MOV AL, [SI]
    ADX [DI],AL
    INC DI
    INC SI
    DEC CX
    JNC NEXT
    HLT

如果是按字运算，即两个字节
    LEA SI, M1
    LEA DI, M2
    MOV CX, **10**
    CLC
    NEXT: MOV **AX**, [SI]
    ADC [DI], **AX**
    **ADD SI, 2**
    **ADD DI, 2**
    DEC CX
    JNZ NEXT
    HLT

{% endhighlight %}


### 2.减法指令

#### SUB 

> SUB OPRD1, OPRD2

和ADD类似，适用于两个字节数和两个多字节数，对多字节数就不适合了

----

#### SBB

> SBB OPRD1, OPRD2

OPRD1 - OPRD2 - CF -> OPRD1

SBB指令多用于两个多字节数的相减运算。

----


#### DEC

和INC类似，不影响CF

//延时程序
MOV BL, 2
NEXT1: MOV CX, 0FFFFH
NEXT2: DEC CX 
JNZ NEXT2 ;ZF=0 转NEXT2
DEC BL
JNZ NEXT1 ;ZF=0 转NEXT1
HLT

----


#### NEG

> NEG OPRD

求补码 也就是用0-操作数

* 执行之后一般会使得CF=1（进位标志），除非给定的操作数为零才会使得CF=0.
* 当指定的操作数的值为80H或为8000H，则执行NEG指令后，结果不变，但0F置1（溢出标志），其他情况下OF均为0.

----

#### CMP

> CMP OPRD1, OPRD2

OPRD1-OPRD2，结果不要，主要是为了影响标志位

指令执行的结果不影响目标操作数，仅影响标志位（CF），用作比较两个数的大小

CMP AX, BX（不带符号数）：

> 若AX>=BX -> CF=0（进位/借位标志）
> 
> 若AX<BX -> CF=1
> 
> 若AX=BX  -> CF=1,ZF=1（结果为0标志）  带符号数：OF和SF共同决定
（最高位标志和次高位/最高位进位标志）
> OF和SF状态相同 AX>=BX
> 
> OF和SF状态不同 AX<BX 

----

#### 例子🌰：

    LEA BX, MAX
    LEA SI, BUF
    MOV CL, 20
    MOV AL, [SI]
NEXT:INC SI
    CMP AL, [SI]
    JNC GOON ;CF=0的时候转移，即AL>=SI的时候
    XCHG [SI], AL ;交换指令，两者交换
GOON: DEC CL
    JNZ NEXT ;CL-1不为0转移到NEXT
    MOV [BX], AL
    HLT


### 3.乘法指令

* 乘除运算指令均采用隐含寻址方式

#### MUL 无符号乘法

乘法指令采用隐含寻址，隐含了存放被乘数的累加器AL或AX，以及存放结果的AX（16位）或AX和DX（32位）

> MUL OPRD 

操作数OPRD不能是立即数

* 如果OPRD为字节数，AL * OPRD -> AX
* 如果OPRD为16位数，AX * OPRD -> DXAX

例子🌰：
MUL BYTE PTR[BX] `说明是一个字节数`

----
#### IMUL 有符号乘法

与MUL的要求是一样的，但是原理不一样

* 对两个操作数取补码，然后做乘法运算，然后将乘法结果取补码

----
### 4.除法指令

**要求被除数一定是除数的2倍字长**

其余和乘法要求一样

`DIV`是无符号除法指令，`IDIV`有符号除法指令

* 若OPRD为字节数：AX/OPRD

AL = 商          AH =  余数

* 若OPRD为双字节数：DXAX/OPRD

AX = 商          DX = 余数






