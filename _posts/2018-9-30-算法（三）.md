---
layout: post
title: 算法————复杂度（下）
feature-img: "assets/img/background/pexels-photo7.jpeg"
thumbnail: "assets/img/background/pexels-photo7.jpeg"
tags: [算法,面试]
---

> 世界上的一切都在做出回答，<br>
> 迟迟不来的是提问的时机。                   
> <p align="right">——若则·萨拉马戈</p>

今天继续算法复杂度分析。大概有四个点：**最好情况时间复杂度**、**最坏情况时间复杂度**、**平均情况时间复杂度**、**均摊时间复杂度**。

下面分别看一下


### 1.最好、最坏情况时间复杂度
----

举个例子🌰先：

```
int found(){
    int pos=-1;
    for(int i=0;i<array.size;i++){
        if(array[i] == x){
            pos = i;
            break;
        }
    }
}
```

这段代码的功能是查找x，并返回其在数组的位置。代码的时间复杂度是多少，还是O(n)吗？

因为要查找的x可能会出现在任何位置，假如他在第一个位置，只需要查找一次就找到了，所以时间复杂度为O(1)。即最好情况时间复杂度。

如果他在数组的最后一个位置，要查找n次才行，所以时间复杂度为O(n)。即最坏情况时间复杂度。

但是这两种极端情况发生的概率并不大，所以引入平均情况时间复杂度。

### 2.平均情况时间复杂度
----

数字出现在所有位置的概率都是` 1/n `，然后第一个位置查一次，第二个位置查两次，以此类推，最后算下来得到公式：

$$ 1*1/n + 2*1/n + ····· $$

时间复杂度仍为O(n)。

### 3.均摊时间复杂度

这个用的不是特别多。在代码执行的所有复杂度情况中，绝大部分是低级别的复杂度，个别情况是高时间复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。


