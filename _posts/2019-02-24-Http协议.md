---
layout: post
title: HTTP协议详解
feature-img: "assets/img/background/pexels-photo5.jpeg"
thumbnail: "assets/img/background/pexels-photo5.jpeg"
tags: [,]
---

>  斗志软弱无力无偿不可。

* TOC
{:toc}

## HTTP概况

* HTTP是构建于TCP/IP协议基础之上的，默认端口号是80端口
* HTTP是无连接无状态的

无连接的含义是：**每次连接只处理一个技术**。服务器处理完客户的请求之后，并受到客户的应答，就断开连接。后来采用了Keep-Alive技术。

无状态是指：协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送HTTP请求之后，服务器根据请求会发送数据，但是不会记录任何信息。

HTTP的这种特性优缺点都有，优点是减轻了服务器负担，每一次请求不会造成不必要的连接占用，缺点在于可能会传输大量重复的内容信息。

为了解决HTTP无状态的缺点，Session和Cookie技术就出现了。

### 延伸：Session和Cookie区别

* Cookies：采用的是在客户端保持登录状态的方案。

Cookies是服务器在本地机器上存储的小段文本。服务器用HTTP头向客户端发送Cookies，在客户端上，浏览器解析这些Cookies并将它们保存一个本地文件，它会自动将同一服务器的任何请求绑定Cookies。

Cookies的内容包括名字、值。过期时间、路径和域。路径和域一起构成Cookie的作用范围。若不设置过期时间，则这个Cookie的生命期为浏览器会话期间，关闭了就消失。
    
* Session：采用的是在服务器端保持状态的方案。

服务器使用一种类似散列表的结构来保存信息。当程序为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已经包含了一个session标识（sessionID）：如果已经包含，则说明已经为此客户端创建过session，服务器就按照sessionID把这个session检索出来使用（检索不到的话就新建一个）；如果没有包含，就为客户端创建一个session并且生成一个与此session相关联的sessionID，在本次响应中返回给客户端。

由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。

## HTTP 报文结构

开始行、首部行、实体主体

### 请求报文

1. 开始行也叫请求行，由方法、【空格】、URL【空格】、HTTP版本 组成

#### HTTP请求方式

* GET 请求指定的页面信息，并返回实体主体。
* POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
* PUT 从客户端向服务器传送的数据取代指定的文档的内容。
* DELETE 请求服务器删除指定的页面。

#### GET和POST区别

GET和POST是HTTP协议中的两种发送请求的方式，GET和POST本质上就是TCP链接。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

1. 最直观的，GET使用URL或Cookie传参，而POST通过Request Body传递参数。
2. POST比GET更安全
3. GET提交数据有长度限制，POST可以很大。

**这个是必答的：**GET和POST最大的区别主要是GET请求是**幂等性**的，但是POST不是。所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试**重试**。如果用get请求增数据，会有**重复操作的风险**，而这种重复操作可能会导致副作用。

#### 请求头

1. User-Agent：产生请求的浏览器类型。
2. Accept：客户端可识别的响应内容类型列表;
3. Accept-Language：客户端可接受的自然语言;
4. Accept-Encoding：客户端可接受的编码压缩格式;
5. Accept-Charset：可接受的应答的字符集;
6. Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;
7. Connection：连接方式(close 或 keep-alive);

> HTTP 1.1默认开启长连接。使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束。

8. Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;
9. 请求包体：在POST方法中使用。
10. Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
11. If-Modified-Since：文档的最后改动时间


### 响应报文

1. 开始行：也叫请求行，由HTTP版本、【空格】、状态码 组成（状态码见下面）
2. 首部行：由首部字段名、【空格】、值组成

#### 响应头

1. Allow 服务器支持哪些请求方法（如GET、POST等）。
2. Content-Encoding 文档的编码（Encode）方法。
3. Content-Length 表示内容长度。只有当浏览器使用**持久HTTP连接**时才需要这个数据。
4. Content-Type 表示后面的文档属于什么MIME类型。
5. Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。
6. Expires 应该在什么时候认为文档已经过期，从而不再缓存它。
7. Last-Modified 文档的最后改动时间。
8. Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。
9. Server 服务器名字。
10. Set-Cookie 设置和页面关联的Cookie。
11. ETag：被请求变量的实体值。ETag是一个可以与Web资源关联的记号（MD5值）。
12. Cache-Control：这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。



## HTTP断点续传

要实现断点续传功能，通常需要客户端记录下当前的下载进度，并且需要在续传的时候通知服务端本次需要下载的片段。

HTTP 1.1定义了HTTP头 `Range`和`Content-Range`字段。

1. 客户端下载一个1024K的文件，已经下载了其中512K
2. 网络中断，客户端请求续传，因此需要在HTTP头中申明本次需要续传的片段：Range:bytes=512000-，这个头通知服务端从文件的512K位置开始传输文件。
3. 服务端收到断点续传请求，从文件的512K位置开始传输，并且在HTTP头中增加：Content-Range:bytes 512000-/1024000，并且此时服务端返回的HTTP状态码应该是206，而不是200。


## HTTP 1.1/2.0

### HTTP1.1

目前使用最为广泛，引入了关键性能优化：KeepAlive，chunked编码传输，字节范围请求，请求流水线等。

* KeepAlive：HTTP1.0中使用需要添加请求头Connection：Keep-Alive，而在HTTP1.1中所有的连接都是默认长连接。
* chunked编码传输：该编码将实体分块并逐块表明长度，直到长度为0表示停止传输停止。这在实体长度未知的时候很有用。
* 字节范围请求：就是上面说的`Range`和`Content-Range`，断点续传
* Pipelining流水线：客户端可通过同一个TCP连接同时发送多个请求。如果客户端需要请求两个资源，以前的做法是在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求；而管道机制则允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。

### HTTP 2.0

HTTP2.0是下一代HTTP协议，目前用的比较少。

* 多路复用（二进制分帧）。复用TCP连接则不同，虽然依然遵循请求-响应模式，但客户端发送多个请求和服务端给出多个响应的顺序不受限制，这样既避免了"队头堵塞"，又能更快获取响应。在复用同一个TCP连接时，服务器同时(或先后)收到了A、B两个请求，先回应A请求，但由于处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。HTTP/2长连接可以理解成全双工的协议。
* HTTP/2 长连接中的数据包是不按请求-响应顺序发送的，一个完整的请求或响应(称一个数据流stream，每个数据流都有一个独一无二的编号)可能会分成非连续多次发送。数据包发送的时候，都必须标记所属的数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧）取消这个数据流。HTTP 1.1 取消数据流的唯一方法，就是关闭TCP连接；HTTP/2 取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级，优先级越高，服务器就会越早响应。

## HTTP/HTTPS比较

HTTPS是超文本传输安全协议，经由HTTP进行通信，但利用SSL/TLS来加密数据包。主要是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

与HTTP不同，默认工作在443端口，工作流程如下：

* TCP三次同步握手
* 客户端验证服务器数字证书
* DH算法协商对称加密算法的密匙，hash算法的密匙
* SSL安全加密隧道协商完成
* 网页以加密的方式进行传输，用协商的对称加密算法和密匙加密保证数据机密性，用协商的hash算法保证数据完整性，不被篡改。

## HTTP状态码

### 1XX消息

表示请求已经被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并且以空行结束。（HTTP/1.0协议没有定义1XX）

#### 100 Continue

服务器已经接收到请求头，并且客户端应继续发送请求主体。

#### 101 Switching Protocols

服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。

#### 102 Processing

WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。

### 2XX成功

这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。

#### 200 OK
请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。
#### 201 Created
请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其URI已经随Location头信息返回。假如需要的资源无法及时建立的话，应当返回'202 Accepted'。
#### 202 Accepted
服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。
#### 203 Non-Authoritative Information（自HTTP / 1.1起）
服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。
#### 204 No Content
服务器成功处理了请求，没有返回任何内容。
#### 205 Reset Content
服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。
#### 206 Partial Content（RFC 7233）
服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。
#### 207 Multi-Status（WebDAV；RFC 4918）
代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。
#### 208 Already Reported （WebDAV；RFC 5842）
DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。
#### 226 IM Used （RFC 3229）
服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。

### 3XX重定向

这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。

#### 300 Multiple Choices
被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。

#### 301 Moved Permanently
被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。
注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。
#### 302 Found
要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。

#### 303 See Other
对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。
新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。
注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。
#### 304 Not Modified
表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。

#### 305 Use Proxy
被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。许多HTTP客户端（像是Mozilla[25]和Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。

#### 307 Temporary Redirect
在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。
#### 308 Permanent Redirect (RFC 7538)
请求和所有将来的请求应该使用另一个URI重复。 307和308重复302和301的行为，但不允许HTTP方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。[29]

### 4XX客户端错误

这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。

#### 400 Bad Request
由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。

#### 401 Unauthorized（RFC 7235）
类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。
注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。
#### 402 Payment Required
该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。
#### 403 Forbidden

服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。

#### 404 Not Found

请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。

#### 405 Method Not Allowed
请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。
鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。

#### 406 Not Acceptable

请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。
除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。

#### 407 Proxy Authentication Required（RFC 2617）
与401响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。

#### 408 Request Timeout
请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。

#### 409 Conflict
表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突（英语：Edit conflict）。

### 5XX服务器错误

表示服务器无法完成明显有效的请求，这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生。

#### 500 Internal Server Error
通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。

#### 501 Not Implemented
服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）

#### 502 Bad Gateway
作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

#### 503 Service Unavailable
由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。[61]如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。

#### 504 Gateway Timeout
作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。某些代理服务器在DNS查询超时时会返回400或者500错误。






